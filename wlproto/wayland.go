// Generated by gowls using arguments "--package wlproto --output wayland.go wayland.xml". DO NOT EDIT.
// https://github.com/friedelschoen/wayland/cmd/gowls
//
// XML file : wayland.xml
//
// wayland Protocol Copyright:
//
// Copyright © 2008-2011 Kristian Høgsberg
// Copyright © 2010-2011 Intel Corporation
// Copyright © 2012-2013 Collabora, Ltd.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice (including the
// next paragraph) shall be included in all copies or substantial
// portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Package wlproto contains wayland-protocol wayland
package wlproto

import wayland "github.com/friedelschoen/wayland"
import "fmt"
import "syscall"

// WlDisplay : core global object
//
// The core global object.  This is a special singleton object.  It
// is used for internal Wayland protocol features.
type WlDisplay struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlDisplayHandlers struct {
	OnError    wayland.EventHandler
	OnDeleteID wayland.EventHandler
	Unhandled  wayland.EventHandler
}

func (h WlDisplayHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlDisplayErrorEvent:
		if h.OnError != nil && h.OnError.Handle(e) {
			return true
		}
	case *WlDisplayDeleteIDEvent:
		if h.OnDeleteID != nil && h.OnDeleteID.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlDisplay : core global object
//
// The core global object.  This is a special singleton object.  It
// is used for internal Wayland protocol features.
func NewWlDisplay(handler wayland.EventHandler) *WlDisplay {
	return &WlDisplay{Handler: handler}
}
func (i *WlDisplay) Name() string {
	return "wl_display"
}

// Sync : asynchronous roundtrip
//
// The sync request asks the server to emit the 'done' event
// on the returned wl_callback object.  Since requests are
// handled in-order and events are delivered in-order, this can
// be used as a barrier to ensure all previous requests and the
// resulting events have been handled.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is undefined and should be ignored.
//
// callbackHandlers : handler for WlCallback, possible events are WlCallbackDone
func (i *WlDisplay) Sync(callbackHandlers wayland.EventHandler) *WlCallback {
	if i == nil || !i.Valid() {
		return nil
	}
	callback := NewWlCallback(callbackHandlers)
	i.Conn().Register(callback)
	i.adjacent = append(i.adjacent, callback)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(callback)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return callback
}

// GetRegistry : get global registry object
//
// This request creates a registry object that allows the client
// to list and bind the global objects available from the
// compositor.
//
// It should be noted that the server side resources consumed in
// response to a get_registry request can only be released when the
// client disconnects, not when the client side proxy is destroyed.
// Therefore, clients should invoke get_registry as infrequently as
// possible to avoid wasting memory.
//
// registryHandlers : handler for WlRegistry, possible events are WlRegistryGlobal, WlRegistryGlobalRemove
func (i *WlDisplay) GetRegistry(registryHandlers wayland.EventHandler) *WlRegistry {
	if i == nil || !i.Valid() {
		return nil
	}
	registry := NewWlRegistry(registryHandlers)
	i.Conn().Register(registry)
	i.adjacent = append(i.adjacent, registry)
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(registry)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return registry
}

// WlDisplayError : global error values
//
// These errors are global and can be emitted in response to any
// server request.
type WlDisplayError uint32

const (
	// WlDisplayErrorInvalidObject : server couldn't find object
	WlDisplayErrorInvalidObject WlDisplayError = 0
	// WlDisplayErrorInvalidMethod : method doesn't exist on the specified interface or malformed request
	WlDisplayErrorInvalidMethod WlDisplayError = 1
	// WlDisplayErrorNoMemory : server is out of memory
	WlDisplayErrorNoMemory WlDisplayError = 2
	// WlDisplayErrorImplementation : implementation error in compositor
	WlDisplayErrorImplementation WlDisplayError = 3
)

func (e WlDisplayError) Name() string {
	switch e {
	case WlDisplayErrorInvalidObject:
		return "invalid_object"
	case WlDisplayErrorInvalidMethod:
		return "invalid_method"
	case WlDisplayErrorNoMemory:
		return "no_memory"
	case WlDisplayErrorImplementation:
		return "implementation"
	default:
		return ""
	}
}
func (e WlDisplayError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlDisplayErrorEvent : fatal error event
//
// The error event is sent out when a fatal (non-recoverable)
// error has occurred.  The object_id argument is the object
// where the error occurred, most often in response to a request
// to that object.  The code identifies the error and is defined
// by the object interface.  As such, each interface defines its
// own set of error codes.  The message is a brief description
// of the error, for (debugging) convenience.
type WlDisplayErrorEvent struct {
	objectID wayland.Proxy
	code     uint32
	message  string
	proxy    wayland.Proxy
}

// ObjectID object where the error occurred
func (e *WlDisplayErrorEvent) ObjectID() wayland.Proxy {
	return e.objectID
}

// Code error code
func (e *WlDisplayErrorEvent) Code() uint32 {
	return e.code
}

// Message error description
func (e *WlDisplayErrorEvent) Message() string {
	return e.message
}

func (e *WlDisplayErrorEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDisplayDeleteIDEvent : acknowledge object ID deletion
//
// This event is used internally by the object ID management
// logic. When a client deletes an object that it had created,
// the server will send this event to acknowledge that it has
// seen the delete request. When the client receives this event,
// it will know that it can safely reuse the object ID.
type WlDisplayDeleteIDEvent struct {
	id    uint32
	proxy wayland.Proxy
}

// ID deleted object ID
func (e *WlDisplayDeleteIDEvent) ID() uint32 {
	return e.id
}

func (e *WlDisplayDeleteIDEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlDisplay) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlDisplayErrorEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.objectID = r.ReadObject()
		e.code = r.ReadUint()
		e.message = r.ReadString()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlDisplayDeleteIDEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.id = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlRegistry : global registry object
//
// The singleton global registry object.  The server has a number of
// global objects that are available to all clients.  These objects
// typically represent an actual object in the server (for example,
// an input device) or they are singleton objects that provide
// extension functionality.
//
// When a client creates a registry object, the registry object
// will emit a global event for each global currently in the
// registry.  Globals come and go as a result of device or
// monitor hotplugs, reconfiguration or other events, and the
// registry will send out global and global_remove events to
// keep the client up to date with the changes.  To mark the end
// of the initial burst of events, the client can use the
// wl_display.sync request immediately after calling
// wl_display.get_registry.
//
// A client can bind to a global object by using the bind
// request.  This creates a client-side handle that lets the object
// emit events to the client and lets the client invoke requests on
// the object.
type WlRegistry struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlRegistryHandlers struct {
	OnGlobal       wayland.EventHandler
	OnGlobalRemove wayland.EventHandler
	Unhandled      wayland.EventHandler
}

func (h WlRegistryHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlRegistryGlobalEvent:
		if h.OnGlobal != nil && h.OnGlobal.Handle(e) {
			return true
		}
	case *WlRegistryGlobalRemoveEvent:
		if h.OnGlobalRemove != nil && h.OnGlobalRemove.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlRegistry : global registry object
//
// The singleton global registry object.  The server has a number of
// global objects that are available to all clients.  These objects
// typically represent an actual object in the server (for example,
// an input device) or they are singleton objects that provide
// extension functionality.
//
// When a client creates a registry object, the registry object
// will emit a global event for each global currently in the
// registry.  Globals come and go as a result of device or
// monitor hotplugs, reconfiguration or other events, and the
// registry will send out global and global_remove events to
// keep the client up to date with the changes.  To mark the end
// of the initial burst of events, the client can use the
// wl_display.sync request immediately after calling
// wl_display.get_registry.
//
// A client can bind to a global object by using the bind
// request.  This creates a client-side handle that lets the object
// emit events to the client and lets the client invoke requests on
// the object.
func NewWlRegistry(handler wayland.EventHandler) *WlRegistry {
	return &WlRegistry{Handler: handler}
}
func (i *WlRegistry) Name() string {
	return "wl_registry"
}

// Bind : bind an object to the display
//
// Binds a new, client-created object to the server using the
// specified name as the identifier.
//
// name : unique numeric name of the object
func (i *WlRegistry) Bind(name uint32, iface string, version uint32, id wayland.Proxy) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	w.WriteUint(uint32(name))
	w.WriteString(iface)
	w.WriteUint(version)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlRegistryGlobalEvent : announce global object
//
// Notify the client of global objects.
//
// The event notifies the client that a global object with
// the given name is now available, and it implements the
// given version of the given interface.
type WlRegistryGlobalEvent struct {
	name       uint32
	interface_ string
	version    uint32
	proxy      wayland.Proxy
}

// Name numeric name of the global object
func (e *WlRegistryGlobalEvent) Name() uint32 {
	return e.name
}

// Interface interface implemented by the object
func (e *WlRegistryGlobalEvent) Interface() string {
	return e.interface_
}

// Version interface version
func (e *WlRegistryGlobalEvent) Version() uint32 {
	return e.version
}

func (e *WlRegistryGlobalEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlRegistryGlobalRemoveEvent : announce removal of global object
//
// Notify the client of removed global objects.
//
// This event notifies the client that the global identified
// by name is no longer available.  If the client bound to
// the global using the bind request, the client should now
// destroy that object.
//
// The object remains valid and requests to the object will be
// ignored until the client destroys it, to avoid races between
// the global going away and a client sending a request to it.
type WlRegistryGlobalRemoveEvent struct {
	name  uint32
	proxy wayland.Proxy
}

// Name numeric name of the global object
func (e *WlRegistryGlobalRemoveEvent) Name() uint32 {
	return e.name
}

func (e *WlRegistryGlobalRemoveEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlRegistry) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlRegistryGlobalEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.name = r.ReadUint()
		e.interface_ = r.ReadString()
		e.version = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlRegistryGlobalRemoveEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.name = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlCallback : callback object
//
// Clients can handle the 'done' event to get notified when
// the related request is done.
//
// Note, because wl_callback objects are created from multiple independent
// factory interfaces, the wl_callback interface is frozen at version 1.
type WlCallback struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlCallbackHandlers struct {
	OnDone    wayland.EventHandler
	Unhandled wayland.EventHandler
}

func (h WlCallbackHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlCallbackDoneEvent:
		if h.OnDone != nil && h.OnDone.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlCallback : callback object
//
// Clients can handle the 'done' event to get notified when
// the related request is done.
//
// Note, because wl_callback objects are created from multiple independent
// factory interfaces, the wl_callback interface is frozen at version 1.
func NewWlCallback(handler wayland.EventHandler) *WlCallback {
	return &WlCallback{Handler: handler}
}
func (i *WlCallback) Name() string {
	return "wl_callback"
}

// WlCallbackDoneEvent : done event
//
// Notify the client when the related request is done.
type WlCallbackDoneEvent struct {
	callbackData uint32
	proxy        wayland.Proxy
}

// CallbackData request-specific data for the callback
func (e *WlCallbackDoneEvent) CallbackData() uint32 {
	return e.callbackData
}

func (e *WlCallbackDoneEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlCallback) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlCallbackDoneEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.callbackData = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlCompositor : the compositor singleton
//
// A compositor.  This object is a singleton global.  The
// compositor is in charge of combining the contents of multiple
// surfaces into one displayable output.
type WlCompositor struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlCompositor : the compositor singleton
//
// A compositor.  This object is a singleton global.  The
// compositor is in charge of combining the contents of multiple
// surfaces into one displayable output.
func NewWlCompositor() *WlCompositor {
	return &WlCompositor{}
}
func (i *WlCompositor) Name() string {
	return "wl_compositor"
}

// CreateSurface : create new surface
//
// Ask the compositor to create a new surface.
//
// idHandlers : handler for WlSurface, possible events are WlSurfaceEnter, WlSurfaceLeave, WlSurfacePreferredBufferScale, WlSurfacePreferredBufferTransform
func (i *WlCompositor) CreateSurface(idHandlers wayland.EventHandler) *WlSurface {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlSurface(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// CreateRegion : create new region
//
// Ask the compositor to create a new region.
func (i *WlCompositor) CreateRegion() *WlRegion {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlRegion()
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// WlShmPool : a shared memory pool
//
// The wl_shm_pool object encapsulates a piece of memory shared
// between the compositor and client.  Through the wl_shm_pool
// object, the client can allocate shared memory wl_buffer objects.
// All objects created through the same pool share the same
// underlying mapped memory. Reusing the mapped memory avoids the
// setup/teardown overhead and is useful when interactively resizing
// a surface or for many small buffers.
type WlShmPool struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlShmPool : a shared memory pool
//
// The wl_shm_pool object encapsulates a piece of memory shared
// between the compositor and client.  Through the wl_shm_pool
// object, the client can allocate shared memory wl_buffer objects.
// All objects created through the same pool share the same
// underlying mapped memory. Reusing the mapped memory avoids the
// setup/teardown overhead and is useful when interactively resizing
// a surface or for many small buffers.
func NewWlShmPool() *WlShmPool {
	return &WlShmPool{}
}
func (i *WlShmPool) Name() string {
	return "wl_shm_pool"
}

// CreateBuffer : create a buffer from the pool
//
// Create a wl_buffer object from the pool.
//
// The buffer is created offset bytes into the pool and has
// width and height as specified.  The stride argument specifies
// the number of bytes from the beginning of one row to the beginning
// of the next.  The format is the pixel format of the buffer and
// must be one of those advertised through the wl_shm.format event.
//
// A buffer will keep a reference to the pool it was created from
// so it is valid to destroy the pool immediately after creating
// a buffer from it.
//
// offset : buffer byte offset within the pool
// width : buffer width, in pixels
// height : buffer height, in pixels
// stride : number of bytes from the beginning of one row to the beginning of the next row
// format : buffer pixel format
//
// idHandlers : handler for WlBuffer, possible events are WlBufferRelease
func (i *WlShmPool) CreateBuffer(offset int32, width int32, height int32, stride int32, format WlShmFormat, idHandlers wayland.EventHandler) *WlBuffer {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlBuffer(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	w.WriteInt(offset)
	w.WriteInt(width)
	w.WriteInt(height)
	w.WriteInt(stride)
	w.WriteUint(uint32(format))
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// Destroy : destroy the pool
//
// Destroy the shared memory pool.
//
// The mmapped memory will be released when all
// buffers that have been created from this pool
// are gone.
func (i *WlShmPool) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Resize : change the size of the pool mapping
//
// This request will cause the server to remap the backing memory
// for the pool from the file descriptor passed when the pool was
// created, but using the new size.  This request can only be
// used to make the pool bigger.
//
// This request only changes the amount of bytes that are mmapped
// by the server and does not touch the file corresponding to the
// file descriptor passed at creation time. It is the client's
// responsibility to ensure that the file is at least as big as
// the new pool size.
//
// size : new size of the pool, in bytes
func (i *WlShmPool) Resize(size int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	w.WriteInt(size)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlShm : shared memory support
//
// A singleton global object that provides support for shared
// memory.
//
// Clients can create wl_shm_pool objects using the create_pool
// request.
//
// On binding the wl_shm object one or more format events
// are emitted to inform clients about the valid pixel formats
// that can be used for buffers.
type WlShm struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlShmHandlers struct {
	OnFormat  wayland.EventHandler
	Unhandled wayland.EventHandler
}

func (h WlShmHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlShmFormatEvent:
		if h.OnFormat != nil && h.OnFormat.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlShm : shared memory support
//
// A singleton global object that provides support for shared
// memory.
//
// Clients can create wl_shm_pool objects using the create_pool
// request.
//
// On binding the wl_shm object one or more format events
// are emitted to inform clients about the valid pixel formats
// that can be used for buffers.
func NewWlShm(handler wayland.EventHandler) *WlShm {
	return &WlShm{Handler: handler}
}
func (i *WlShm) Name() string {
	return "wl_shm"
}

// CreatePool : create a shm pool
//
// Create a new wl_shm_pool object.
//
// The pool can be used to create shared memory based buffer
// objects.  The server will mmap size bytes of the passed file
// descriptor, to use as backing memory for the pool.
//
// fd : file descriptor for the pool
// size : pool size, in bytes
func (i *WlShm) CreatePool(fd int, size int32) *WlShmPool {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlShmPool()
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	w.WriteFd(fd)
	w.WriteInt(size)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// Release : release the shm object
//
// Using this request a client can tell the server that it is not going to
// use the shm object anymore.
//
// Objects created via this interface remain unaffected.
func (i *WlShm) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlShm) Destroy() {
	i.Release()
}

// WlShmError : wl_shm error values
//
// These errors can be emitted in response to wl_shm requests.
type WlShmError uint32

const (
	// WlShmErrorInvalidFormat : buffer format is not known
	WlShmErrorInvalidFormat WlShmError = 0
	// WlShmErrorInvalidStride : invalid size or stride during pool or buffer creation
	WlShmErrorInvalidStride WlShmError = 1
	// WlShmErrorInvalidFd : mmapping the file descriptor failed
	WlShmErrorInvalidFd WlShmError = 2
)

func (e WlShmError) Name() string {
	switch e {
	case WlShmErrorInvalidFormat:
		return "invalid_format"
	case WlShmErrorInvalidStride:
		return "invalid_stride"
	case WlShmErrorInvalidFd:
		return "invalid_fd"
	default:
		return ""
	}
}
func (e WlShmError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlShmFormat : pixel formats
//
// This describes the memory layout of an individual pixel.
//
// All renderers should support argb8888 and xrgb8888 but any other
// formats are optional and may not be supported by the particular
// renderer in use.
//
// The drm format codes match the macros defined in drm_fourcc.h, except
// argb8888 and xrgb8888. The formats actually supported by the compositor
// will be reported by the format event.
//
// For all wl_shm formats and unless specified in another protocol
// extension, pre-multiplied alpha is used for pixel values.
type WlShmFormat uint32

const (
	// WlShmFormatArgb8888 : 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	WlShmFormatArgb8888 WlShmFormat = 0
	// WlShmFormatXrgb8888 : 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	WlShmFormatXrgb8888 WlShmFormat = 1
	// WlShmFormatC8 : 8-bit color index format, [7:0] C
	WlShmFormatC8 WlShmFormat = 0x20203843
	// WlShmFormatRgb332 : 8-bit RGB format, [7:0] R:G:B 3:3:2
	WlShmFormatRgb332 WlShmFormat = 0x38424752
	// WlShmFormatBgr233 : 8-bit BGR format, [7:0] B:G:R 2:3:3
	WlShmFormatBgr233 WlShmFormat = 0x38524742
	// WlShmFormatXrgb4444 : 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	WlShmFormatXrgb4444 WlShmFormat = 0x32315258
	// WlShmFormatXbgr4444 : 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	WlShmFormatXbgr4444 WlShmFormat = 0x32314258
	// WlShmFormatRgbx4444 : 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	WlShmFormatRgbx4444 WlShmFormat = 0x32315852
	// WlShmFormatBgrx4444 : 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	WlShmFormatBgrx4444 WlShmFormat = 0x32315842
	// WlShmFormatArgb4444 : 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	WlShmFormatArgb4444 WlShmFormat = 0x32315241
	// WlShmFormatAbgr4444 : 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	WlShmFormatAbgr4444 WlShmFormat = 0x32314241
	// WlShmFormatRgba4444 : 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	WlShmFormatRgba4444 WlShmFormat = 0x32314152
	// WlShmFormatBgra4444 : 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	WlShmFormatBgra4444 WlShmFormat = 0x32314142
	// WlShmFormatXrgb1555 : 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	WlShmFormatXrgb1555 WlShmFormat = 0x35315258
	// WlShmFormatXbgr1555 : 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	WlShmFormatXbgr1555 WlShmFormat = 0x35314258
	// WlShmFormatRgbx5551 : 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	WlShmFormatRgbx5551 WlShmFormat = 0x35315852
	// WlShmFormatBgrx5551 : 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	WlShmFormatBgrx5551 WlShmFormat = 0x35315842
	// WlShmFormatArgb1555 : 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	WlShmFormatArgb1555 WlShmFormat = 0x35315241
	// WlShmFormatAbgr1555 : 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	WlShmFormatAbgr1555 WlShmFormat = 0x35314241
	// WlShmFormatRgba5551 : 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	WlShmFormatRgba5551 WlShmFormat = 0x35314152
	// WlShmFormatBgra5551 : 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	WlShmFormatBgra5551 WlShmFormat = 0x35314142
	// WlShmFormatRgb565 : 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	WlShmFormatRgb565 WlShmFormat = 0x36314752
	// WlShmFormatBgr565 : 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	WlShmFormatBgr565 WlShmFormat = 0x36314742
	// WlShmFormatRgb888 : 24-bit RGB format, [23:0] R:G:B little endian
	WlShmFormatRgb888 WlShmFormat = 0x34324752
	// WlShmFormatBgr888 : 24-bit BGR format, [23:0] B:G:R little endian
	WlShmFormatBgr888 WlShmFormat = 0x34324742
	// WlShmFormatXbgr8888 : 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	WlShmFormatXbgr8888 WlShmFormat = 0x34324258
	// WlShmFormatRgbx8888 : 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	WlShmFormatRgbx8888 WlShmFormat = 0x34325852
	// WlShmFormatBgrx8888 : 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	WlShmFormatBgrx8888 WlShmFormat = 0x34325842
	// WlShmFormatAbgr8888 : 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	WlShmFormatAbgr8888 WlShmFormat = 0x34324241
	// WlShmFormatRgba8888 : 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	WlShmFormatRgba8888 WlShmFormat = 0x34324152
	// WlShmFormatBgra8888 : 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	WlShmFormatBgra8888 WlShmFormat = 0x34324142
	// WlShmFormatXrgb2101010 : 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	WlShmFormatXrgb2101010 WlShmFormat = 0x30335258
	// WlShmFormatXbgr2101010 : 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	WlShmFormatXbgr2101010 WlShmFormat = 0x30334258
	// WlShmFormatRgbx1010102 : 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	WlShmFormatRgbx1010102 WlShmFormat = 0x30335852
	// WlShmFormatBgrx1010102 : 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	WlShmFormatBgrx1010102 WlShmFormat = 0x30335842
	// WlShmFormatArgb2101010 : 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	WlShmFormatArgb2101010 WlShmFormat = 0x30335241
	// WlShmFormatAbgr2101010 : 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	WlShmFormatAbgr2101010 WlShmFormat = 0x30334241
	// WlShmFormatRgba1010102 : 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	WlShmFormatRgba1010102 WlShmFormat = 0x30334152
	// WlShmFormatBgra1010102 : 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	WlShmFormatBgra1010102 WlShmFormat = 0x30334142
	// WlShmFormatYuyv : packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	WlShmFormatYuyv WlShmFormat = 0x56595559
	// WlShmFormatYvyu : packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	WlShmFormatYvyu WlShmFormat = 0x55595659
	// WlShmFormatUyvy : packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	WlShmFormatUyvy WlShmFormat = 0x59565955
	// WlShmFormatVyuy : packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	WlShmFormatVyuy WlShmFormat = 0x59555956
	// WlShmFormatAyuv : packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	WlShmFormatAyuv WlShmFormat = 0x56555941
	// WlShmFormatNv12 : 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	WlShmFormatNv12 WlShmFormat = 0x3231564e
	// WlShmFormatNv21 : 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	WlShmFormatNv21 WlShmFormat = 0x3132564e
	// WlShmFormatNv16 : 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	WlShmFormatNv16 WlShmFormat = 0x3631564e
	// WlShmFormatNv61 : 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	WlShmFormatNv61 WlShmFormat = 0x3136564e
	// WlShmFormatYuv410 : 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv410 WlShmFormat = 0x39565559
	// WlShmFormatYvu410 : 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu410 WlShmFormat = 0x39555659
	// WlShmFormatYuv411 : 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv411 WlShmFormat = 0x31315559
	// WlShmFormatYvu411 : 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu411 WlShmFormat = 0x31315659
	// WlShmFormatYuv420 : 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv420 WlShmFormat = 0x32315559
	// WlShmFormatYvu420 : 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu420 WlShmFormat = 0x32315659
	// WlShmFormatYuv422 : 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv422 WlShmFormat = 0x36315559
	// WlShmFormatYvu422 : 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu422 WlShmFormat = 0x36315659
	// WlShmFormatYuv444 : 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv444 WlShmFormat = 0x34325559
	// WlShmFormatYvu444 : 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu444 WlShmFormat = 0x34325659
	// WlShmFormatR8 : [7:0] R
	WlShmFormatR8 WlShmFormat = 0x20203852
	// WlShmFormatR16 : [15:0] R little endian
	WlShmFormatR16 WlShmFormat = 0x20363152
	// WlShmFormatRg88 : [15:0] R:G 8:8 little endian
	WlShmFormatRg88 WlShmFormat = 0x38384752
	// WlShmFormatGr88 : [15:0] G:R 8:8 little endian
	WlShmFormatGr88 WlShmFormat = 0x38385247
	// WlShmFormatRg1616 : [31:0] R:G 16:16 little endian
	WlShmFormatRg1616 WlShmFormat = 0x32334752
	// WlShmFormatGr1616 : [31:0] G:R 16:16 little endian
	WlShmFormatGr1616 WlShmFormat = 0x32335247
	// WlShmFormatXrgb16161616f : [63:0] x:R:G:B 16:16:16:16 little endian
	WlShmFormatXrgb16161616f WlShmFormat = 0x48345258
	// WlShmFormatXbgr16161616f : [63:0] x:B:G:R 16:16:16:16 little endian
	WlShmFormatXbgr16161616f WlShmFormat = 0x48344258
	// WlShmFormatArgb16161616f : [63:0] A:R:G:B 16:16:16:16 little endian
	WlShmFormatArgb16161616f WlShmFormat = 0x48345241
	// WlShmFormatAbgr16161616f : [63:0] A:B:G:R 16:16:16:16 little endian
	WlShmFormatAbgr16161616f WlShmFormat = 0x48344241
	// WlShmFormatXyuv8888 : [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	WlShmFormatXyuv8888 WlShmFormat = 0x56555958
	// WlShmFormatVuy888 : [23:0] Cr:Cb:Y 8:8:8 little endian
	WlShmFormatVuy888 WlShmFormat = 0x34325556
	// WlShmFormatVuy101010 : Y followed by U then V, 10:10:10. Non-linear modifier only
	WlShmFormatVuy101010 WlShmFormat = 0x30335556
	// WlShmFormatY210 : [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	WlShmFormatY210 WlShmFormat = 0x30313259
	// WlShmFormatY212 : [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	WlShmFormatY212 WlShmFormat = 0x32313259
	// WlShmFormatY216 : [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	WlShmFormatY216 WlShmFormat = 0x36313259
	// WlShmFormatY410 : [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	WlShmFormatY410 WlShmFormat = 0x30313459
	// WlShmFormatY412 : [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WlShmFormatY412 WlShmFormat = 0x32313459
	// WlShmFormatY416 : [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	WlShmFormatY416 WlShmFormat = 0x36313459
	// WlShmFormatXvyu2101010 : [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	WlShmFormatXvyu2101010 WlShmFormat = 0x30335658
	// WlShmFormatXvyu1216161616 : [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WlShmFormatXvyu1216161616 WlShmFormat = 0x36335658
	// WlShmFormatXvyu16161616 : [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	WlShmFormatXvyu16161616 WlShmFormat = 0x38345658
	// WlShmFormatY0l0 : [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WlShmFormatY0l0 WlShmFormat = 0x304c3059
	// WlShmFormatX0l0 : [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WlShmFormatX0l0 WlShmFormat = 0x304c3058
	// WlShmFormatY0l2 : [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	WlShmFormatY0l2 WlShmFormat = 0x324c3059
	// WlShmFormatX0l2 : [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
	WlShmFormatX0l2        WlShmFormat = 0x324c3058
	WlShmFormatYuv4208bit  WlShmFormat = 0x38305559
	WlShmFormatYuv42010bit WlShmFormat = 0x30315559
	WlShmFormatXrgb8888A8  WlShmFormat = 0x38415258
	WlShmFormatXbgr8888A8  WlShmFormat = 0x38414258
	WlShmFormatRgbx8888A8  WlShmFormat = 0x38415852
	WlShmFormatBgrx8888A8  WlShmFormat = 0x38415842
	WlShmFormatRgb888A8    WlShmFormat = 0x38413852
	WlShmFormatBgr888A8    WlShmFormat = 0x38413842
	WlShmFormatRgb565A8    WlShmFormat = 0x38413552
	WlShmFormatBgr565A8    WlShmFormat = 0x38413542
	// WlShmFormatNv24 : non-subsampled Cr:Cb plane
	WlShmFormatNv24 WlShmFormat = 0x3432564e
	// WlShmFormatNv42 : non-subsampled Cb:Cr plane
	WlShmFormatNv42 WlShmFormat = 0x3234564e
	// WlShmFormatP210 : 2x1 subsampled Cr:Cb plane, 10 bit per channel
	WlShmFormatP210 WlShmFormat = 0x30313250
	// WlShmFormatP010 : 2x2 subsampled Cr:Cb plane 10 bits per channel
	WlShmFormatP010 WlShmFormat = 0x30313050
	// WlShmFormatP012 : 2x2 subsampled Cr:Cb plane 12 bits per channel
	WlShmFormatP012 WlShmFormat = 0x32313050
	// WlShmFormatP016 : 2x2 subsampled Cr:Cb plane 16 bits per channel
	WlShmFormatP016 WlShmFormat = 0x36313050
	// WlShmFormatAxbxgxrx106106106106 : [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	WlShmFormatAxbxgxrx106106106106 WlShmFormat = 0x30314241
	// WlShmFormatNv15 : 2x2 subsampled Cr:Cb plane
	WlShmFormatNv15 WlShmFormat = 0x3531564e
	WlShmFormatQ410 WlShmFormat = 0x30313451
	WlShmFormatQ401 WlShmFormat = 0x31303451
	// WlShmFormatXrgb16161616 : [63:0] x:R:G:B 16:16:16:16 little endian
	WlShmFormatXrgb16161616 WlShmFormat = 0x38345258
	// WlShmFormatXbgr16161616 : [63:0] x:B:G:R 16:16:16:16 little endian
	WlShmFormatXbgr16161616 WlShmFormat = 0x38344258
	// WlShmFormatArgb16161616 : [63:0] A:R:G:B 16:16:16:16 little endian
	WlShmFormatArgb16161616 WlShmFormat = 0x38345241
	// WlShmFormatAbgr16161616 : [63:0] A:B:G:R 16:16:16:16 little endian
	WlShmFormatAbgr16161616 WlShmFormat = 0x38344241
	// WlShmFormatC1 : [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
	WlShmFormatC1 WlShmFormat = 0x20203143
	// WlShmFormatC2 : [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
	WlShmFormatC2 WlShmFormat = 0x20203243
	// WlShmFormatC4 : [7:0] C0:C1 4:4 two pixels/byte
	WlShmFormatC4 WlShmFormat = 0x20203443
	// WlShmFormatD1 : [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
	WlShmFormatD1 WlShmFormat = 0x20203144
	// WlShmFormatD2 : [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
	WlShmFormatD2 WlShmFormat = 0x20203244
	// WlShmFormatD4 : [7:0] D0:D1 4:4 two pixels/byte
	WlShmFormatD4 WlShmFormat = 0x20203444
	// WlShmFormatD8 : [7:0] D
	WlShmFormatD8 WlShmFormat = 0x20203844
	// WlShmFormatR1 : [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
	WlShmFormatR1 WlShmFormat = 0x20203152
	// WlShmFormatR2 : [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
	WlShmFormatR2 WlShmFormat = 0x20203252
	// WlShmFormatR4 : [7:0] R0:R1 4:4 two pixels/byte
	WlShmFormatR4 WlShmFormat = 0x20203452
	// WlShmFormatR10 : [15:0] x:R 6:10 little endian
	WlShmFormatR10 WlShmFormat = 0x20303152
	// WlShmFormatR12 : [15:0] x:R 4:12 little endian
	WlShmFormatR12 WlShmFormat = 0x20323152
	// WlShmFormatAvuy8888 : [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
	WlShmFormatAvuy8888 WlShmFormat = 0x59555641
	// WlShmFormatXvuy8888 : [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
	WlShmFormatXvuy8888 WlShmFormat = 0x59555658
	// WlShmFormatP030 : 2x2 subsampled Cr:Cb plane 10 bits per channel packed
	WlShmFormatP030 WlShmFormat = 0x30333050
)

func (e WlShmFormat) Name() string {
	switch e {
	case WlShmFormatArgb8888:
		return "argb8888"
	case WlShmFormatXrgb8888:
		return "xrgb8888"
	case WlShmFormatC8:
		return "c8"
	case WlShmFormatRgb332:
		return "rgb332"
	case WlShmFormatBgr233:
		return "bgr233"
	case WlShmFormatXrgb4444:
		return "xrgb4444"
	case WlShmFormatXbgr4444:
		return "xbgr4444"
	case WlShmFormatRgbx4444:
		return "rgbx4444"
	case WlShmFormatBgrx4444:
		return "bgrx4444"
	case WlShmFormatArgb4444:
		return "argb4444"
	case WlShmFormatAbgr4444:
		return "abgr4444"
	case WlShmFormatRgba4444:
		return "rgba4444"
	case WlShmFormatBgra4444:
		return "bgra4444"
	case WlShmFormatXrgb1555:
		return "xrgb1555"
	case WlShmFormatXbgr1555:
		return "xbgr1555"
	case WlShmFormatRgbx5551:
		return "rgbx5551"
	case WlShmFormatBgrx5551:
		return "bgrx5551"
	case WlShmFormatArgb1555:
		return "argb1555"
	case WlShmFormatAbgr1555:
		return "abgr1555"
	case WlShmFormatRgba5551:
		return "rgba5551"
	case WlShmFormatBgra5551:
		return "bgra5551"
	case WlShmFormatRgb565:
		return "rgb565"
	case WlShmFormatBgr565:
		return "bgr565"
	case WlShmFormatRgb888:
		return "rgb888"
	case WlShmFormatBgr888:
		return "bgr888"
	case WlShmFormatXbgr8888:
		return "xbgr8888"
	case WlShmFormatRgbx8888:
		return "rgbx8888"
	case WlShmFormatBgrx8888:
		return "bgrx8888"
	case WlShmFormatAbgr8888:
		return "abgr8888"
	case WlShmFormatRgba8888:
		return "rgba8888"
	case WlShmFormatBgra8888:
		return "bgra8888"
	case WlShmFormatXrgb2101010:
		return "xrgb2101010"
	case WlShmFormatXbgr2101010:
		return "xbgr2101010"
	case WlShmFormatRgbx1010102:
		return "rgbx1010102"
	case WlShmFormatBgrx1010102:
		return "bgrx1010102"
	case WlShmFormatArgb2101010:
		return "argb2101010"
	case WlShmFormatAbgr2101010:
		return "abgr2101010"
	case WlShmFormatRgba1010102:
		return "rgba1010102"
	case WlShmFormatBgra1010102:
		return "bgra1010102"
	case WlShmFormatYuyv:
		return "yuyv"
	case WlShmFormatYvyu:
		return "yvyu"
	case WlShmFormatUyvy:
		return "uyvy"
	case WlShmFormatVyuy:
		return "vyuy"
	case WlShmFormatAyuv:
		return "ayuv"
	case WlShmFormatNv12:
		return "nv12"
	case WlShmFormatNv21:
		return "nv21"
	case WlShmFormatNv16:
		return "nv16"
	case WlShmFormatNv61:
		return "nv61"
	case WlShmFormatYuv410:
		return "yuv410"
	case WlShmFormatYvu410:
		return "yvu410"
	case WlShmFormatYuv411:
		return "yuv411"
	case WlShmFormatYvu411:
		return "yvu411"
	case WlShmFormatYuv420:
		return "yuv420"
	case WlShmFormatYvu420:
		return "yvu420"
	case WlShmFormatYuv422:
		return "yuv422"
	case WlShmFormatYvu422:
		return "yvu422"
	case WlShmFormatYuv444:
		return "yuv444"
	case WlShmFormatYvu444:
		return "yvu444"
	case WlShmFormatR8:
		return "r8"
	case WlShmFormatR16:
		return "r16"
	case WlShmFormatRg88:
		return "rg88"
	case WlShmFormatGr88:
		return "gr88"
	case WlShmFormatRg1616:
		return "rg1616"
	case WlShmFormatGr1616:
		return "gr1616"
	case WlShmFormatXrgb16161616f:
		return "xrgb16161616f"
	case WlShmFormatXbgr16161616f:
		return "xbgr16161616f"
	case WlShmFormatArgb16161616f:
		return "argb16161616f"
	case WlShmFormatAbgr16161616f:
		return "abgr16161616f"
	case WlShmFormatXyuv8888:
		return "xyuv8888"
	case WlShmFormatVuy888:
		return "vuy888"
	case WlShmFormatVuy101010:
		return "vuy101010"
	case WlShmFormatY210:
		return "y210"
	case WlShmFormatY212:
		return "y212"
	case WlShmFormatY216:
		return "y216"
	case WlShmFormatY410:
		return "y410"
	case WlShmFormatY412:
		return "y412"
	case WlShmFormatY416:
		return "y416"
	case WlShmFormatXvyu2101010:
		return "xvyu2101010"
	case WlShmFormatXvyu1216161616:
		return "xvyu12_16161616"
	case WlShmFormatXvyu16161616:
		return "xvyu16161616"
	case WlShmFormatY0l0:
		return "y0l0"
	case WlShmFormatX0l0:
		return "x0l0"
	case WlShmFormatY0l2:
		return "y0l2"
	case WlShmFormatX0l2:
		return "x0l2"
	case WlShmFormatYuv4208bit:
		return "yuv420_8bit"
	case WlShmFormatYuv42010bit:
		return "yuv420_10bit"
	case WlShmFormatXrgb8888A8:
		return "xrgb8888_a8"
	case WlShmFormatXbgr8888A8:
		return "xbgr8888_a8"
	case WlShmFormatRgbx8888A8:
		return "rgbx8888_a8"
	case WlShmFormatBgrx8888A8:
		return "bgrx8888_a8"
	case WlShmFormatRgb888A8:
		return "rgb888_a8"
	case WlShmFormatBgr888A8:
		return "bgr888_a8"
	case WlShmFormatRgb565A8:
		return "rgb565_a8"
	case WlShmFormatBgr565A8:
		return "bgr565_a8"
	case WlShmFormatNv24:
		return "nv24"
	case WlShmFormatNv42:
		return "nv42"
	case WlShmFormatP210:
		return "p210"
	case WlShmFormatP010:
		return "p010"
	case WlShmFormatP012:
		return "p012"
	case WlShmFormatP016:
		return "p016"
	case WlShmFormatAxbxgxrx106106106106:
		return "axbxgxrx106106106106"
	case WlShmFormatNv15:
		return "nv15"
	case WlShmFormatQ410:
		return "q410"
	case WlShmFormatQ401:
		return "q401"
	case WlShmFormatXrgb16161616:
		return "xrgb16161616"
	case WlShmFormatXbgr16161616:
		return "xbgr16161616"
	case WlShmFormatArgb16161616:
		return "argb16161616"
	case WlShmFormatAbgr16161616:
		return "abgr16161616"
	case WlShmFormatC1:
		return "c1"
	case WlShmFormatC2:
		return "c2"
	case WlShmFormatC4:
		return "c4"
	case WlShmFormatD1:
		return "d1"
	case WlShmFormatD2:
		return "d2"
	case WlShmFormatD4:
		return "d4"
	case WlShmFormatD8:
		return "d8"
	case WlShmFormatR1:
		return "r1"
	case WlShmFormatR2:
		return "r2"
	case WlShmFormatR4:
		return "r4"
	case WlShmFormatR10:
		return "r10"
	case WlShmFormatR12:
		return "r12"
	case WlShmFormatAvuy8888:
		return "avuy8888"
	case WlShmFormatXvuy8888:
		return "xvuy8888"
	case WlShmFormatP030:
		return "p030"
	default:
		return ""
	}
}
func (e WlShmFormat) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("format(%d)", e)
	}
	return fmt.Sprintf("format(%s)", name)
}

// WlShmFormatEvent : pixel format description
//
// Informs the client about a valid pixel format that
// can be used for buffers. Known formats include
// argb8888 and xrgb8888.
type WlShmFormatEvent struct {
	format WlShmFormat
	proxy  wayland.Proxy
}

// Format buffer pixel format
func (e *WlShmFormatEvent) Format() WlShmFormat {
	return e.format
}

func (e *WlShmFormatEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlShm) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlShmFormatEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.format = WlShmFormat(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlBuffer : content for a wl_surface
//
// A buffer provides the content for a wl_surface. Buffers are
// created through factory interfaces such as wl_shm, wp_linux_buffer_params
// (from the linux-dmabuf protocol extension) or similar. It has a width and
// a height and can be attached to a wl_surface, but the mechanism by which a
// client provides and updates the contents is defined by the buffer factory
// interface.
//
// Color channels are assumed to be electrical rather than optical (in other
// words, encoded with a transfer function) unless otherwise specified. If
// the buffer uses a format that has an alpha channel, the alpha channel is
// assumed to be premultiplied into the electrical color channel values
// (after transfer function encoding) unless otherwise specified.
//
// Note, because wl_buffer objects are created from multiple independent
// factory interfaces, the wl_buffer interface is frozen at version 1.
type WlBuffer struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlBufferHandlers struct {
	OnRelease wayland.EventHandler
	Unhandled wayland.EventHandler
}

func (h WlBufferHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlBufferReleaseEvent:
		if h.OnRelease != nil && h.OnRelease.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlBuffer : content for a wl_surface
//
// A buffer provides the content for a wl_surface. Buffers are
// created through factory interfaces such as wl_shm, wp_linux_buffer_params
// (from the linux-dmabuf protocol extension) or similar. It has a width and
// a height and can be attached to a wl_surface, but the mechanism by which a
// client provides and updates the contents is defined by the buffer factory
// interface.
//
// Color channels are assumed to be electrical rather than optical (in other
// words, encoded with a transfer function) unless otherwise specified. If
// the buffer uses a format that has an alpha channel, the alpha channel is
// assumed to be premultiplied into the electrical color channel values
// (after transfer function encoding) unless otherwise specified.
//
// Note, because wl_buffer objects are created from multiple independent
// factory interfaces, the wl_buffer interface is frozen at version 1.
func NewWlBuffer(handler wayland.EventHandler) *WlBuffer {
	return &WlBuffer{Handler: handler}
}
func (i *WlBuffer) Name() string {
	return "wl_buffer"
}

// Destroy : destroy a buffer
//
// Destroy a buffer. If and how you need to release the backing
// storage is defined by the buffer factory interface.
//
// For possible side-effects to a surface, see wl_surface.attach.
func (i *WlBuffer) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlBufferReleaseEvent : compositor releases buffer
//
// Sent when this wl_buffer is no longer used by the compositor.
//
// For more information on when release events may or may not be sent,
// and what consequences it has, please see the description of
// wl_surface.attach.
//
// If a client receives a release event before the frame callback
// requested in the same wl_surface.commit that attaches this
// wl_buffer to a surface, then the client is immediately free to
// reuse the buffer and its backing storage, and does not need a
// second buffer for the next surface content update. Typically
// this is possible, when the compositor maintains a copy of the
// wl_surface contents, e.g. as a GL texture. This is an important
// optimization for GL(ES) compositors with wl_shm clients.
type WlBufferReleaseEvent struct {
	proxy wayland.Proxy
}

func (e *WlBufferReleaseEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlBuffer) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlBufferReleaseEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlDataOffer : offer to transfer data
//
// A wl_data_offer represents a piece of data offered for transfer
// by another client (the source client).  It is used by the
// copy-and-paste and drag-and-drop mechanisms.  The offer
// describes the different mime types that the data can be
// converted to and provides the mechanism for transferring the
// data directly from the source client.
type WlDataOffer struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlDataOfferHandlers struct {
	OnOffer         wayland.EventHandler
	OnSourceActions wayland.EventHandler
	OnAction        wayland.EventHandler
	Unhandled       wayland.EventHandler
}

func (h WlDataOfferHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlDataOfferOfferEvent:
		if h.OnOffer != nil && h.OnOffer.Handle(e) {
			return true
		}
	case *WlDataOfferSourceActionsEvent:
		if h.OnSourceActions != nil && h.OnSourceActions.Handle(e) {
			return true
		}
	case *WlDataOfferActionEvent:
		if h.OnAction != nil && h.OnAction.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlDataOffer : offer to transfer data
//
// A wl_data_offer represents a piece of data offered for transfer
// by another client (the source client).  It is used by the
// copy-and-paste and drag-and-drop mechanisms.  The offer
// describes the different mime types that the data can be
// converted to and provides the mechanism for transferring the
// data directly from the source client.
func NewWlDataOffer(handler wayland.EventHandler) *WlDataOffer {
	return &WlDataOffer{Handler: handler}
}
func (i *WlDataOffer) Name() string {
	return "wl_data_offer"
}

// Accept : accept one of the offered mime types
//
// Indicate that the client can accept the given mime type, or
// NULL for not accepted.
//
// For objects of version 2 or older, this request is used by the
// client to give feedback whether the client can receive the given
// mime type, or NULL if none is accepted; the feedback does not
// determine whether the drag-and-drop operation succeeds or not.
//
// For objects of version 3 or newer, this request determines the
// final result of the drag-and-drop operation. If the end result
// is that no mime types were accepted, the drag-and-drop operation
// will be cancelled and the corresponding drag source will receive
// wl_data_source.cancelled. Clients may still use this event in
// conjunction with wl_data_source.action for feedback.
//
// serial : serial number of the accept request
// mimeType : mime type accepted by the client
func (i *WlDataOffer) Accept(serial uint32, mimeType string) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	w.WriteUint(uint32(serial))
	if mimeType == "" {
		w.WriteUint(0)
	} else {
		w.WriteString(mimeType)
	}
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Receive : request that the data is transferred
//
// To transfer the offered data, the client issues this request
// and indicates the mime type it wants to receive.  The transfer
// happens through the passed file descriptor (typically created
// with the pipe system call).  The source client writes the data
// in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until
// EOF and then closes its end, at which point the transfer is
// complete.
//
// This request may happen multiple times for different mime types,
// both before and after wl_data_device.drop. Drag-and-drop destination
// clients may preemptively fetch data or examine it more closely to
// determine acceptance.
//
// mimeType : mime type desired by receiver
// fd : file descriptor for data transfer
func (i *WlDataOffer) Receive(mimeType string, fd int) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	w.WriteString(mimeType)
	w.WriteFd(fd)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Destroy : destroy data offer
//
// Destroy the data offer.
func (i *WlDataOffer) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Finish : the offer will no longer be used
//
// Notifies the compositor that the drag destination successfully
// finished the drag-and-drop operation.
//
// Upon receiving this request, the compositor will emit
// wl_data_source.dnd_finished on the drag source client.
//
// It is a client error to perform other requests than
// wl_data_offer.destroy after this one. It is also an error to perform
// this request after a NULL mime type has been set in
// wl_data_offer.accept or no action was received through
// wl_data_offer.action.
//
// If wl_data_offer.finish request is received for a non drag and drop
// operation, the invalid_finish protocol error is raised.
func (i *WlDataOffer) Finish() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 3)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetActions : set the available/preferred drag-and-drop actions
//
// Sets the actions that the destination side client supports for
// this operation. This request may trigger the emission of
// wl_data_source.action and wl_data_offer.action events if the compositor
// needs to change the selected action.
//
// This request can be called multiple times throughout the
// drag-and-drop operation, typically in response to wl_data_device.enter
// or wl_data_device.motion events.
//
// This request determines the final result of the drag-and-drop
// operation. If the end result is that no action is accepted,
// the drag source will receive wl_data_source.cancelled.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, and the preferred_action
// argument must only contain one of those values set, otherwise it
// will result in a protocol error.
//
// While managing an "ask" action, the destination drag-and-drop client
// may perform further wl_data_offer.receive requests, and is expected
// to perform one last wl_data_offer.set_actions request with a preferred
// action other than "ask" (and optionally wl_data_offer.accept) before
// requesting wl_data_offer.finish, in order to convey the action selected
// by the user. If the preferred action is not in the
// wl_data_offer.source_actions mask, an error will be raised.
//
// If the "ask" action is dismissed (e.g. user cancellation), the client
// is expected to perform wl_data_offer.destroy right away.
//
// This request can only be made on drag-and-drop offers, a protocol error
// will be raised otherwise.
//
// dndActions : actions supported by the destination client
// preferredAction : action preferred by the destination client
func (i *WlDataOffer) SetActions(dndActions WlDataDeviceManagerDndAction, preferredAction WlDataDeviceManagerDndAction) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 4)
	w.WriteUint(uint32(dndActions))
	w.WriteUint(uint32(preferredAction))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlDataOfferError :
type WlDataOfferError uint32

const (
	// WlDataOfferErrorInvalidFinish : finish request was called untimely
	WlDataOfferErrorInvalidFinish WlDataOfferError = 0
	// WlDataOfferErrorInvalidActionMask : action mask contains invalid values
	WlDataOfferErrorInvalidActionMask WlDataOfferError = 1
	// WlDataOfferErrorInvalidAction : action argument has an invalid value
	WlDataOfferErrorInvalidAction WlDataOfferError = 2
	// WlDataOfferErrorInvalidOffer : offer doesn't accept this request
	WlDataOfferErrorInvalidOffer WlDataOfferError = 3
)

func (e WlDataOfferError) Name() string {
	switch e {
	case WlDataOfferErrorInvalidFinish:
		return "invalid_finish"
	case WlDataOfferErrorInvalidActionMask:
		return "invalid_action_mask"
	case WlDataOfferErrorInvalidAction:
		return "invalid_action"
	case WlDataOfferErrorInvalidOffer:
		return "invalid_offer"
	default:
		return ""
	}
}
func (e WlDataOfferError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlDataOfferOfferEvent : advertise offered mime type
//
// Sent immediately after creating the wl_data_offer object.  One
// event per offered mime type.
type WlDataOfferOfferEvent struct {
	mimeType string
	proxy    wayland.Proxy
}

// MimeType offered mime type
func (e *WlDataOfferOfferEvent) MimeType() string {
	return e.mimeType
}

func (e *WlDataOfferOfferEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataOfferSourceActionsEvent : notify the source-side available actions
//
// This event indicates the actions offered by the data source. It
// will be sent immediately after creating the wl_data_offer object,
// or anytime the source side changes its offered actions through
// wl_data_source.set_actions.
type WlDataOfferSourceActionsEvent struct {
	sourceActions WlDataDeviceManagerDndAction
	proxy         wayland.Proxy
}

// SourceActions actions offered by the data source
func (e *WlDataOfferSourceActionsEvent) SourceActions() WlDataDeviceManagerDndAction {
	return e.sourceActions
}

func (e *WlDataOfferSourceActionsEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataOfferActionEvent : notify the selected action
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation in response to destination side action changes through
// wl_data_offer.set_actions.
//
// This event will no longer be emitted after wl_data_device.drop
// happened on the drag-and-drop destination, the client must
// honor the last action received, or the last preferred one set
// through wl_data_offer.set_actions when handling an "ask" action.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. Prior to
// receiving wl_data_device.drop, the chosen action may change (e.g.
// due to keyboard modifiers being pressed). At the time of receiving
// wl_data_device.drop the drag-and-drop destination must honor the
// last action received.
//
// Action changes may still happen after wl_data_device.drop,
// especially on "ask" actions, where the drag-and-drop destination
// may choose another action afterwards. Action changes happening
// at this stage are always the result of inter-client negotiation, the
// compositor shall no longer be able to induce a different action.
//
// Upon "ask" actions, it is expected that the drag-and-drop destination
// may potentially choose a different action and/or mime type,
// based on wl_data_offer.source_actions and finally chosen by the
// user (e.g. popping up a menu with the available options). The
// final wl_data_offer.set_actions and wl_data_offer.accept requests
// must happen before the call to wl_data_offer.finish.
type WlDataOfferActionEvent struct {
	dndAction WlDataDeviceManagerDndAction
	proxy     wayland.Proxy
}

// DndAction action selected by the compositor
func (e *WlDataOfferActionEvent) DndAction() WlDataDeviceManagerDndAction {
	return e.dndAction
}

func (e *WlDataOfferActionEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlDataOffer) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlDataOfferOfferEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.mimeType = r.ReadString()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlDataOfferSourceActionsEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.sourceActions = WlDataDeviceManagerDndAction(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlDataOfferActionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.dndAction = WlDataDeviceManagerDndAction(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlDataSource : offer to transfer data
//
// The wl_data_source object is the source side of a wl_data_offer.
// It is created by the source client in a data transfer and
// provides a way to describe the offered data and a way to respond
// to requests to transfer the data.
type WlDataSource struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlDataSourceHandlers struct {
	OnTarget           wayland.EventHandler
	OnSend             wayland.EventHandler
	OnCancelled        wayland.EventHandler
	OnDndDropPerformed wayland.EventHandler
	OnDndFinished      wayland.EventHandler
	OnAction           wayland.EventHandler
	Unhandled          wayland.EventHandler
}

func (h WlDataSourceHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlDataSourceTargetEvent:
		if h.OnTarget != nil && h.OnTarget.Handle(e) {
			return true
		}
	case *WlDataSourceSendEvent:
		if h.OnSend != nil && h.OnSend.Handle(e) {
			return true
		}
	case *WlDataSourceCancelledEvent:
		if h.OnCancelled != nil && h.OnCancelled.Handle(e) {
			return true
		}
	case *WlDataSourceDndDropPerformedEvent:
		if h.OnDndDropPerformed != nil && h.OnDndDropPerformed.Handle(e) {
			return true
		}
	case *WlDataSourceDndFinishedEvent:
		if h.OnDndFinished != nil && h.OnDndFinished.Handle(e) {
			return true
		}
	case *WlDataSourceActionEvent:
		if h.OnAction != nil && h.OnAction.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlDataSource : offer to transfer data
//
// The wl_data_source object is the source side of a wl_data_offer.
// It is created by the source client in a data transfer and
// provides a way to describe the offered data and a way to respond
// to requests to transfer the data.
func NewWlDataSource(handler wayland.EventHandler) *WlDataSource {
	return &WlDataSource{Handler: handler}
}
func (i *WlDataSource) Name() string {
	return "wl_data_source"
}

// Offer : add an offered mime type
//
// This request adds a mime type to the set of mime types
// advertised to targets.  Can be called several times to offer
// multiple types.
//
// mimeType : mime type offered by the data source
func (i *WlDataSource) Offer(mimeType string) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	w.WriteString(mimeType)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Destroy : destroy the data source
//
// Destroy the data source.
func (i *WlDataSource) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetActions : set the available drag-and-drop actions
//
// Sets the actions that the source side client supports for this
// operation. This request may trigger wl_data_source.action and
// wl_data_offer.action events if the compositor needs to change the
// selected action.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, otherwise it will result
// in a protocol error.
//
// This request must be made once only, and can only be made on sources
// used in drag-and-drop, so it must be performed before
// wl_data_device.start_drag. Attempting to use the source other than
// for drag-and-drop will raise a protocol error.
//
// dndActions : actions supported by the data source
func (i *WlDataSource) SetActions(dndActions WlDataDeviceManagerDndAction) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	w.WriteUint(uint32(dndActions))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlDataSourceError :
type WlDataSourceError uint32

const (
	// WlDataSourceErrorInvalidActionMask : action mask contains invalid values
	WlDataSourceErrorInvalidActionMask WlDataSourceError = 0
	// WlDataSourceErrorInvalidSource : source doesn't accept this request
	WlDataSourceErrorInvalidSource WlDataSourceError = 1
)

func (e WlDataSourceError) Name() string {
	switch e {
	case WlDataSourceErrorInvalidActionMask:
		return "invalid_action_mask"
	case WlDataSourceErrorInvalidSource:
		return "invalid_source"
	default:
		return ""
	}
}
func (e WlDataSourceError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlDataSourceTargetEvent : a target accepts an offered mime type
//
// Sent when a target accepts pointer_focus or motion events.  If
// a target does not accept any of the offered types, type is NULL.
//
// Used for feedback during drag-and-drop.
type WlDataSourceTargetEvent struct {
	mimeType string
	proxy    wayland.Proxy
}

// MimeType mime type accepted by the target
func (e *WlDataSourceTargetEvent) MimeType() string {
	return e.mimeType
}

func (e *WlDataSourceTargetEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataSourceSendEvent : send the data
//
// Request for data from the client.  Send the data as the
// specified mime type over the passed file descriptor, then
// close it.
type WlDataSourceSendEvent struct {
	mimeType string
	fd       int
	proxy    wayland.Proxy
}

// MimeType mime type for the data
func (e *WlDataSourceSendEvent) MimeType() string {
	return e.mimeType
}

// Fd file descriptor for the data
func (e *WlDataSourceSendEvent) Fd() int {
	return e.fd
}

func (e *WlDataSourceSendEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataSourceCancelledEvent : selection was cancelled
//
// This data source is no longer valid. There are several reasons why
// this could happen:
//
// - The data source has been replaced by another data source.
// - The drag-and-drop operation was performed, but the drop destination
// did not accept any of the mime types offered through
// wl_data_source.target.
// - The drag-and-drop operation was performed, but the drop destination
// did not select any of the actions present in the mask offered through
// wl_data_source.action.
// - The drag-and-drop operation was performed but didn't happen over a
// surface.
// - The compositor cancelled the drag-and-drop operation (e.g. compositor
// dependent timeouts to avoid stale drag-and-drop transfers).
//
// The client should clean up and destroy this data source.
//
// For objects of version 2 or older, wl_data_source.cancelled will
// only be emitted if the data source was replaced by another data
// source.
type WlDataSourceCancelledEvent struct {
	proxy wayland.Proxy
}

func (e *WlDataSourceCancelledEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataSourceDndDropPerformedEvent : the drag-and-drop operation physically finished
//
// The user performed the drop action. This event does not indicate
// acceptance, wl_data_source.cancelled may still be emitted afterwards
// if the drop destination does not accept any mime type.
//
// However, this event might however not be received if the compositor
// cancelled the drag-and-drop operation before this event could happen.
//
// Note that the data_source may still be used in the future and should
// not be destroyed here.
type WlDataSourceDndDropPerformedEvent struct {
	proxy wayland.Proxy
}

func (e *WlDataSourceDndDropPerformedEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataSourceDndFinishedEvent : the drag-and-drop operation concluded
//
// The drop destination finished interoperating with this data
// source, so the client is now free to destroy this data source and
// free all associated data.
//
// If the action used to perform the operation was "move", the
// source can now delete the transferred data.
type WlDataSourceDndFinishedEvent struct {
	proxy wayland.Proxy
}

func (e *WlDataSourceDndFinishedEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataSourceActionEvent : notify the selected action
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation, mainly in response to destination side changes through
// wl_data_offer.set_actions, and as the data device enters/leaves
// surfaces.
//
// It is only possible to receive this event after
// wl_data_source.dnd_drop_performed if the drag-and-drop operation
// ended in an "ask" action, in which case the final wl_data_source.action
// event will happen immediately before wl_data_source.dnd_finished.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. The chosen
// action may change alongside negotiation (e.g. an "ask" action can turn
// into a "move" operation), so the effects of the final action must
// always be applied in wl_data_offer.dnd_finished.
//
// Clients can trigger cursor surface changes from this point, so
// they reflect the current action.
type WlDataSourceActionEvent struct {
	dndAction WlDataDeviceManagerDndAction
	proxy     wayland.Proxy
}

// DndAction action selected by the compositor
func (e *WlDataSourceActionEvent) DndAction() WlDataDeviceManagerDndAction {
	return e.dndAction
}

func (e *WlDataSourceActionEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlDataSource) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlDataSourceTargetEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.mimeType = r.ReadString()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			for _, fd := range msg.FDs {
				syscall.Close(fd)
			}
			return
		}
		e := &WlDataSourceSendEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.mimeType = r.ReadString()
		e.fd = r.ReadFd()
		if i.Handler.Handle(e) {
			return
		}
		for _, fd := range msg.FDs {
			syscall.Close(fd)
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlDataSourceCancelledEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlDataSourceDndDropPerformedEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 4:
		if i.Handler == nil {
			return
		}
		e := &WlDataSourceDndFinishedEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 5:
		if i.Handler == nil {
			return
		}
		e := &WlDataSourceActionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.dndAction = WlDataDeviceManagerDndAction(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlDataDevice : data transfer device
//
// There is one wl_data_device per seat which can be obtained
// from the global wl_data_device_manager singleton.
//
// A wl_data_device provides access to inter-client data transfer
// mechanisms such as copy-and-paste and drag-and-drop.
type WlDataDevice struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlDataDeviceHandlers struct {
	OnDataOffer wayland.EventHandler
	OnEnter     wayland.EventHandler
	OnLeave     wayland.EventHandler
	OnMotion    wayland.EventHandler
	OnDrop      wayland.EventHandler
	OnSelection wayland.EventHandler
	Unhandled   wayland.EventHandler
}

func (h WlDataDeviceHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlDataDeviceDataOfferEvent:
		if h.OnDataOffer != nil && h.OnDataOffer.Handle(e) {
			return true
		}
	case *WlDataDeviceEnterEvent:
		if h.OnEnter != nil && h.OnEnter.Handle(e) {
			return true
		}
	case *WlDataDeviceLeaveEvent:
		if h.OnLeave != nil && h.OnLeave.Handle(e) {
			return true
		}
	case *WlDataDeviceMotionEvent:
		if h.OnMotion != nil && h.OnMotion.Handle(e) {
			return true
		}
	case *WlDataDeviceDropEvent:
		if h.OnDrop != nil && h.OnDrop.Handle(e) {
			return true
		}
	case *WlDataDeviceSelectionEvent:
		if h.OnSelection != nil && h.OnSelection.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlDataDevice : data transfer device
//
// There is one wl_data_device per seat which can be obtained
// from the global wl_data_device_manager singleton.
//
// A wl_data_device provides access to inter-client data transfer
// mechanisms such as copy-and-paste and drag-and-drop.
func NewWlDataDevice(handler wayland.EventHandler) *WlDataDevice {
	return &WlDataDevice{Handler: handler}
}
func (i *WlDataDevice) Name() string {
	return "wl_data_device"
}

// StartDrag : start drag-and-drop operation
//
// This request asks the compositor to start a drag-and-drop
// operation on behalf of the client.
//
// The source argument is the data source that provides the data
// for the eventual data transfer. If source is NULL, enter, leave
// and motion events are sent only to the client that initiated the
// drag and the client is expected to handle the data passing
// internally. If source is destroyed, the drag-and-drop session will be
// cancelled.
//
// The origin surface is the surface where the drag originates and
// the client must have an active implicit grab that matches the
// serial.
//
// The icon surface is an optional (can be NULL) surface that
// provides an icon to be moved around with the cursor.  Initially,
// the top-left corner of the icon surface is placed at the cursor
// hotspot, but subsequent wl_surface.offset requests can move the
// relative position. Attach requests must be confirmed with
// wl_surface.commit as usual. The icon surface is given the role of
// a drag-and-drop icon. If the icon surface already has another role,
// it raises a protocol error.
//
// The input region is ignored for wl_surfaces with the role of a
// drag-and-drop icon.
//
// The given source may not be used in any further set_selection or
// start_drag requests. Attempting to reuse a previously-used source
// may send a used_source error.
//
// source : data source for the eventual transfer
// origin : surface where the drag originates
// icon : drag-and-drop icon surface
// serial : serial number of the implicit grab on the origin
func (i *WlDataDevice) StartDrag(source *WlDataSource, origin *WlSurface, icon *WlSurface, serial uint32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if source == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(source)
	}
	w.WriteObject(origin)
	if icon == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(icon)
	}
	w.WriteUint(uint32(serial))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetSelection : copy data to the selection
//
// This request asks the compositor to set the selection
// to the data from the source on behalf of the client.
//
// To unset the selection, set the source to NULL.
//
// The given source may not be used in any further set_selection or
// start_drag requests. Attempting to reuse a previously-used source
// may send a used_source error.
//
// source : data source for the selection
// serial : serial number of the event that triggered this request
func (i *WlDataDevice) SetSelection(source *WlDataSource, serial uint32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if source == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(source)
	}
	w.WriteUint(uint32(serial))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Release : destroy data device
//
// This request destroys the data device.
func (i *WlDataDevice) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlDataDevice) Destroy() {
	i.Release()
}

// WlDataDeviceError :
type WlDataDeviceError uint32

const (
	// WlDataDeviceErrorRole : given wl_surface has another role
	WlDataDeviceErrorRole WlDataDeviceError = 0
	// WlDataDeviceErrorUsedSource : source has already been used
	WlDataDeviceErrorUsedSource WlDataDeviceError = 1
)

func (e WlDataDeviceError) Name() string {
	switch e {
	case WlDataDeviceErrorRole:
		return "role"
	case WlDataDeviceErrorUsedSource:
		return "used_source"
	default:
		return ""
	}
}
func (e WlDataDeviceError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlDataDeviceDataOfferEvent : introduce a new wl_data_offer
//
// The data_offer event introduces a new wl_data_offer object,
// which will subsequently be used in either the
// data_device.enter event (for drag-and-drop) or the
// data_device.selection event (for selections).  Immediately
// following the data_device.data_offer event, the new data_offer
// object will send out data_offer.offer events to describe the
// mime types it offers.
type WlDataDeviceDataOfferEvent struct {
	id    *WlDataOffer
	proxy wayland.Proxy
}

// ID the new data_offer object
func (e *WlDataDeviceDataOfferEvent) ID() *WlDataOffer {
	return e.id
}

func (e *WlDataDeviceDataOfferEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataDeviceEnterEvent : initiate drag-and-drop session
//
// This event is sent when an active drag-and-drop pointer enters
// a surface owned by the client.  The position of the pointer at
// enter time is provided by the x and y arguments, in surface-local
// coordinates.
type WlDataDeviceEnterEvent struct {
	serial  uint32
	surface *WlSurface
	x       float64
	y       float64
	id      *WlDataOffer
	proxy   wayland.Proxy
}

// Serial serial number of the enter event
func (e *WlDataDeviceEnterEvent) Serial() uint32 {
	return e.serial
}

// Surface client surface entered
func (e *WlDataDeviceEnterEvent) Surface() *WlSurface {
	return e.surface
}

// X surface-local x coordinate
func (e *WlDataDeviceEnterEvent) X() float64 {
	return e.x
}

// Y surface-local y coordinate
func (e *WlDataDeviceEnterEvent) Y() float64 {
	return e.y
}

// ID source data_offer object
func (e *WlDataDeviceEnterEvent) ID() *WlDataOffer {
	return e.id
}

func (e *WlDataDeviceEnterEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataDeviceLeaveEvent : end drag-and-drop session
//
// This event is sent when the drag-and-drop pointer leaves the
// surface and the session ends.  The client must destroy the
// wl_data_offer introduced at enter time at this point.
type WlDataDeviceLeaveEvent struct {
	proxy wayland.Proxy
}

func (e *WlDataDeviceLeaveEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataDeviceMotionEvent : drag-and-drop session motion
//
// This event is sent when the drag-and-drop pointer moves within
// the currently focused surface. The new position of the pointer
// is provided by the x and y arguments, in surface-local
// coordinates.
type WlDataDeviceMotionEvent struct {
	time  uint32
	x     float64
	y     float64
	proxy wayland.Proxy
}

// Time timestamp with millisecond granularity
func (e *WlDataDeviceMotionEvent) Time() uint32 {
	return e.time
}

// X surface-local x coordinate
func (e *WlDataDeviceMotionEvent) X() float64 {
	return e.x
}

// Y surface-local y coordinate
func (e *WlDataDeviceMotionEvent) Y() float64 {
	return e.y
}

func (e *WlDataDeviceMotionEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataDeviceDropEvent : end drag-and-drop session successfully
//
// The event is sent when a drag-and-drop operation is ended
// because the implicit grab is removed.
//
// The drag-and-drop destination is expected to honor the last action
// received through wl_data_offer.action, if the resulting action is
// "copy" or "move", the destination can still perform
// wl_data_offer.receive requests, and is expected to end all
// transfers with a wl_data_offer.finish request.
//
// If the resulting action is "ask", the action will not be considered
// final. The drag-and-drop destination is expected to perform one last
// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
// to cancel the operation.
type WlDataDeviceDropEvent struct {
	proxy wayland.Proxy
}

func (e *WlDataDeviceDropEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlDataDeviceSelectionEvent : advertise new selection
//
// The selection event is sent out to notify the client of a new
// wl_data_offer for the selection for this device.  The
// data_device.data_offer and the data_offer.offer events are
// sent out immediately before this event to introduce the data
// offer object.  The selection event is sent to a client
// immediately before receiving keyboard focus and when a new
// selection is set while the client has keyboard focus.  The
// data_offer is valid until a new data_offer or NULL is received
// or until the client loses keyboard focus.  Switching surface with
// keyboard focus within the same client doesn't mean a new selection
// will be sent.  The client must destroy the previous selection
// data_offer, if any, upon receiving this event.
type WlDataDeviceSelectionEvent struct {
	id    *WlDataOffer
	proxy wayland.Proxy
}

// ID selection data_offer object
func (e *WlDataDeviceSelectionEvent) ID() *WlDataOffer {
	return e.id
}

func (e *WlDataDeviceSelectionEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlDataDevice) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlDataDeviceDataOfferEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		id := r.ReadObject()
		if id != nil {
			e.id = id.(*WlDataOffer)
		}
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlDataDeviceEnterEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		surface := r.ReadObject()
		if surface != nil {
			e.surface = surface.(*WlSurface)
		}
		e.x = r.ReadFixed()
		e.y = r.ReadFixed()
		id := r.ReadObject()
		if id != nil {
			e.id = id.(*WlDataOffer)
		}
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlDataDeviceLeaveEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlDataDeviceMotionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.time = r.ReadUint()
		e.x = r.ReadFixed()
		e.y = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 4:
		if i.Handler == nil {
			return
		}
		e := &WlDataDeviceDropEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 5:
		if i.Handler == nil {
			return
		}
		e := &WlDataDeviceSelectionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		id := r.ReadObject()
		if id != nil {
			e.id = id.(*WlDataOffer)
		}
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlDataDeviceManager : data transfer interface
//
// The wl_data_device_manager is a singleton global object that
// provides access to inter-client data transfer mechanisms such as
// copy-and-paste and drag-and-drop.  These mechanisms are tied to
// a wl_seat and this interface lets a client get a wl_data_device
// corresponding to a wl_seat.
//
// Depending on the version bound, the objects created from the bound
// wl_data_device_manager object will have different requirements for
// functioning properly. See wl_data_source.set_actions,
// wl_data_offer.accept and wl_data_offer.finish for details.
type WlDataDeviceManager struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlDataDeviceManager : data transfer interface
//
// The wl_data_device_manager is a singleton global object that
// provides access to inter-client data transfer mechanisms such as
// copy-and-paste and drag-and-drop.  These mechanisms are tied to
// a wl_seat and this interface lets a client get a wl_data_device
// corresponding to a wl_seat.
//
// Depending on the version bound, the objects created from the bound
// wl_data_device_manager object will have different requirements for
// functioning properly. See wl_data_source.set_actions,
// wl_data_offer.accept and wl_data_offer.finish for details.
func NewWlDataDeviceManager() *WlDataDeviceManager {
	return &WlDataDeviceManager{}
}
func (i *WlDataDeviceManager) Name() string {
	return "wl_data_device_manager"
}

// CreateDataSource : create a new data source
//
// Create a new data source.
//
// idHandlers : handler for WlDataSource, possible events are WlDataSourceTarget, WlDataSourceSend, WlDataSourceCancelled, WlDataSourceDndDropPerformed, WlDataSourceDndFinished, WlDataSourceAction
func (i *WlDataDeviceManager) CreateDataSource(idHandlers wayland.EventHandler) *WlDataSource {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlDataSource(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// GetDataDevice : create a new data device
//
// Create a new data device for a given seat.
//
// seat : seat associated with the data device
//
// idHandlers : handler for WlDataDevice, possible events are WlDataDeviceDataOffer, WlDataDeviceEnter, WlDataDeviceLeave, WlDataDeviceMotion, WlDataDeviceDrop, WlDataDeviceSelection
func (i *WlDataDeviceManager) GetDataDevice(seat *WlSeat, idHandlers wayland.EventHandler) *WlDataDevice {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlDataDevice(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(id)
	w.WriteObject(seat)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// WlDataDeviceManagerDndAction : drag and drop actions
//
// This is a bitmask of the available/preferred actions in a
// drag-and-drop operation.
//
// In the compositor, the selected action is a result of matching the
// actions offered by the source and destination sides.  "action" events
// with a "none" action will be sent to both source and destination if
// there is no match. All further checks will effectively happen on
// (source actions ∩ destination actions).
//
// In addition, compositors may also pick different actions in
// reaction to key modifiers being pressed. One common design that
// is used in major toolkits (and the behavior recommended for
// compositors) is:
//
// - If no modifiers are pressed, the first match (in bit order)
// will be used.
// - Pressing Shift selects "move", if enabled in the mask.
// - Pressing Control selects "copy", if enabled in the mask.
//
// Behavior beyond that is considered implementation-dependent.
// Compositors may for example bind other modifiers (like Alt/Meta)
// or drags initiated with other buttons than BTN_LEFT to specific
// actions (e.g. "ask").
type WlDataDeviceManagerDndAction uint32

const (
	// WlDataDeviceManagerDndActionNone : no action
	WlDataDeviceManagerDndActionNone WlDataDeviceManagerDndAction = 0
	// WlDataDeviceManagerDndActionCopy : copy action
	WlDataDeviceManagerDndActionCopy WlDataDeviceManagerDndAction = 1
	// WlDataDeviceManagerDndActionMove : move action
	WlDataDeviceManagerDndActionMove WlDataDeviceManagerDndAction = 2
	// WlDataDeviceManagerDndActionAsk : ask action
	WlDataDeviceManagerDndActionAsk WlDataDeviceManagerDndAction = 4
)

func (e WlDataDeviceManagerDndAction) Name() string {
	switch e {
	case WlDataDeviceManagerDndActionNone:
		return "none"
	case WlDataDeviceManagerDndActionCopy:
		return "copy"
	case WlDataDeviceManagerDndActionMove:
		return "move"
	case WlDataDeviceManagerDndActionAsk:
		return "ask"
	default:
		return ""
	}
}
func (e WlDataDeviceManagerDndAction) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("dnd_action(%d)", e)
	}
	return fmt.Sprintf("dnd_action(%s)", name)
}

// WlShell : create desktop-style surfaces
//
// This interface is implemented by servers that provide
// desktop-style user interfaces.
//
// It allows clients to associate a wl_shell_surface with
// a basic surface.
//
// Note! This protocol is deprecated and not intended for production use.
// For desktop-style user interfaces, use xdg_shell. Compositors and clients
// should not implement this interface.
type WlShell struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlShell : create desktop-style surfaces
//
// This interface is implemented by servers that provide
// desktop-style user interfaces.
//
// It allows clients to associate a wl_shell_surface with
// a basic surface.
//
// Note! This protocol is deprecated and not intended for production use.
// For desktop-style user interfaces, use xdg_shell. Compositors and clients
// should not implement this interface.
func NewWlShell() *WlShell {
	return &WlShell{}
}
func (i *WlShell) Name() string {
	return "wl_shell"
}

// GetShellSurface : create a shell surface from a surface
//
// Create a shell surface for an existing surface. This gives
// the wl_surface the role of a shell surface. If the wl_surface
// already has another role, it raises a protocol error.
//
// Only one shell surface can be associated with a given surface.
//
// surface : surface to be given the shell surface role
//
// idHandlers : handler for WlShellSurface, possible events are WlShellSurfacePing, WlShellSurfaceConfigure, WlShellSurfacePopupDone
func (i *WlShell) GetShellSurface(surface *WlSurface, idHandlers wayland.EventHandler) *WlShellSurface {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlShellSurface(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	w.WriteObject(surface)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// WlShellError :
type WlShellError uint32

const (
	// WlShellErrorRole : given wl_surface has another role
	WlShellErrorRole WlShellError = 0
)

func (e WlShellError) Name() string {
	switch e {
	case WlShellErrorRole:
		return "role"
	default:
		return ""
	}
}
func (e WlShellError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlShellSurface : desktop-style metadata interface
//
// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides requests to treat surfaces like toplevel, fullscreen
// or popup windows, move, resize or maximize them, associate
// metadata like title and class, etc.
//
// On the server side the object is automatically destroyed when
// the related wl_surface is destroyed. On the client side,
// wl_shell_surface_destroy() must be called before destroying
// the wl_surface object.
type WlShellSurface struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlShellSurfaceHandlers struct {
	OnPing      wayland.EventHandler
	OnConfigure wayland.EventHandler
	OnPopupDone wayland.EventHandler
	Unhandled   wayland.EventHandler
}

func (h WlShellSurfaceHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlShellSurfacePingEvent:
		if h.OnPing != nil && h.OnPing.Handle(e) {
			return true
		}
	case *WlShellSurfaceConfigureEvent:
		if h.OnConfigure != nil && h.OnConfigure.Handle(e) {
			return true
		}
	case *WlShellSurfacePopupDoneEvent:
		if h.OnPopupDone != nil && h.OnPopupDone.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlShellSurface : desktop-style metadata interface
//
// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides requests to treat surfaces like toplevel, fullscreen
// or popup windows, move, resize or maximize them, associate
// metadata like title and class, etc.
//
// On the server side the object is automatically destroyed when
// the related wl_surface is destroyed. On the client side,
// wl_shell_surface_destroy() must be called before destroying
// the wl_surface object.
func NewWlShellSurface(handler wayland.EventHandler) *WlShellSurface {
	return &WlShellSurface{Handler: handler}
}
func (i *WlShellSurface) Name() string {
	return "wl_shell_surface"
}

// Pong : respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive.
//
// serial : serial number of the ping event
func (i *WlShellSurface) Pong(serial uint32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	w.WriteUint(uint32(serial))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Move : start an interactive move
//
// Start a pointer-driven move of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized).
//
// seat : seat whose pointer is used
// serial : serial number of the implicit grab on the pointer
func (i *WlShellSurface) Move(seat *WlSeat, serial uint32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(seat)
	w.WriteUint(uint32(serial))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Resize : start an interactive resize
//
// Start a pointer-driven resizing of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
//
// seat : seat whose pointer is used
// serial : serial number of the implicit grab on the pointer
// edges : which edge or corner is being dragged
func (i *WlShellSurface) Resize(seat *WlSeat, serial uint32, edges WlShellSurfaceResize) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	w.WriteObject(seat)
	w.WriteUint(uint32(serial))
	w.WriteUint(uint32(edges))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetToplevel : make the surface a toplevel surface
//
// Map the surface as a toplevel surface.
//
// A toplevel surface is not fullscreen, maximized or transient.
func (i *WlShellSurface) SetToplevel() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 3)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetTransient : make the surface a transient surface
//
// Map the surface relative to an existing surface.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
//
// The flags argument controls details of the transient behaviour.
//
// parent : parent surface
// x : surface-local x coordinate
// y : surface-local y coordinate
// flags : transient surface behavior
func (i *WlShellSurface) SetTransient(parent *WlSurface, x int32, y int32, flags WlShellSurfaceTransient) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 4)
	w.WriteObject(parent)
	w.WriteInt(x)
	w.WriteInt(y)
	w.WriteUint(uint32(flags))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetFullscreen : make the surface a fullscreen surface
//
// Map the surface as a fullscreen surface.
//
// If an output parameter is given then the surface will be made
// fullscreen on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The client may specify a method to resolve a size conflict
// between the output size and the surface size - this is provided
// through the method parameter.
//
// The framerate parameter is used only when the method is set
// to "driver", to indicate the preferred framerate. A value of 0
// indicates that the client does not care about framerate.  The
// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
//
// A method of "scale" or "driver" implies a scaling operation of
// the surface, either via a direct scaling operation or a change of
// the output mode. This will override any kind of output scaling, so
// that mapping a surface with a buffer size equal to the mode can
// fill the screen independent of buffer_scale.
//
// A method of "fill" means we don't scale up the buffer, however
// any output scale is applied. This means that you may run into
// an edge case where the application maps a buffer with the same
// size of the output mode but buffer_scale 1 (thus making a
// surface larger than the output). In this case it is allowed to
// downscale the results to fit the screen.
//
// The compositor must reply to this request with a configure event
// with the dimensions for the output on which the surface will
// be made fullscreen.
//
// method : method for resolving size conflict
// framerate : framerate in mHz
// output : output on which the surface is to be fullscreen
func (i *WlShellSurface) SetFullscreen(method WlShellSurfaceFullscreenMethod, framerate uint32, output *WlOutput) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 5)
	w.WriteUint(uint32(method))
	w.WriteUint(uint32(framerate))
	if output == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(output)
	}
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetPopup : make the surface a popup surface
//
// Map the surface as a popup.
//
// A popup surface is a transient surface with an added pointer
// grab.
//
// An existing implicit grab will be changed to owner-events mode,
// and the popup grab will continue after the implicit grab ends
// (i.e. releasing the mouse button does not cause the popup to
// be unmapped).
//
// The popup grab continues until the window is destroyed or a
// mouse button is pressed in any other client's window. A click
// in any of the client's surfaces is reported as normal, however,
// clicks in other clients' surfaces will be discarded and trigger
// the callback.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
//
// seat : seat whose pointer is used
// serial : serial number of the implicit grab on the pointer
// parent : parent surface
// x : surface-local x coordinate
// y : surface-local y coordinate
// flags : transient surface behavior
func (i *WlShellSurface) SetPopup(seat *WlSeat, serial uint32, parent *WlSurface, x int32, y int32, flags WlShellSurfaceTransient) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 6)
	w.WriteObject(seat)
	w.WriteUint(uint32(serial))
	w.WriteObject(parent)
	w.WriteInt(x)
	w.WriteInt(y)
	w.WriteUint(uint32(flags))
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetMaximized : make the surface a maximized surface
//
// Map the surface as a maximized surface.
//
// If an output parameter is given then the surface will be
// maximized on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The compositor will reply with a configure event telling
// the expected new surface size. The operation is completed
// on the next buffer attach to this surface.
//
// A maximized surface typically fills the entire output it is
// bound to, except for desktop elements such as panels. This is
// the main difference between a maximized shell surface and a
// fullscreen shell surface.
//
// The details depend on the compositor implementation.
//
// output : output on which the surface is to be maximized
func (i *WlShellSurface) SetMaximized(output *WlOutput) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 7)
	if output == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(output)
	}
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetTitle : set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
//
// title : surface title
func (i *WlShellSurface) SetTitle(title string) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 8)
	w.WriteString(title)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetClass : set surface class
//
// Set a class for the surface.
//
// The surface class identifies the general class of applications
// to which the surface belongs. A common convention is to use the
// file name (or the full path if it is a non-standard location) of
// the application's .desktop file as the class.
//
// class : surface class
func (i *WlShellSurface) SetClass(class string) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 9)
	w.WriteString(class)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlShellSurfaceResize : edge values for resizing
//
// These values are used to indicate which edge of a surface
// is being dragged in a resize operation. The server may
// use this information to adapt its behavior, e.g. choose
// an appropriate cursor image.
type WlShellSurfaceResize uint32

const (
	// WlShellSurfaceResizeNone : no edge
	WlShellSurfaceResizeNone WlShellSurfaceResize = 0
	// WlShellSurfaceResizeTop : top edge
	WlShellSurfaceResizeTop WlShellSurfaceResize = 1
	// WlShellSurfaceResizeBottom : bottom edge
	WlShellSurfaceResizeBottom WlShellSurfaceResize = 2
	// WlShellSurfaceResizeLeft : left edge
	WlShellSurfaceResizeLeft WlShellSurfaceResize = 4
	// WlShellSurfaceResizeTopLeft : top and left edges
	WlShellSurfaceResizeTopLeft WlShellSurfaceResize = 5
	// WlShellSurfaceResizeBottomLeft : bottom and left edges
	WlShellSurfaceResizeBottomLeft WlShellSurfaceResize = 6
	// WlShellSurfaceResizeRight : right edge
	WlShellSurfaceResizeRight WlShellSurfaceResize = 8
	// WlShellSurfaceResizeTopRight : top and right edges
	WlShellSurfaceResizeTopRight WlShellSurfaceResize = 9
	// WlShellSurfaceResizeBottomRight : bottom and right edges
	WlShellSurfaceResizeBottomRight WlShellSurfaceResize = 10
)

func (e WlShellSurfaceResize) Name() string {
	switch e {
	case WlShellSurfaceResizeNone:
		return "none"
	case WlShellSurfaceResizeTop:
		return "top"
	case WlShellSurfaceResizeBottom:
		return "bottom"
	case WlShellSurfaceResizeLeft:
		return "left"
	case WlShellSurfaceResizeTopLeft:
		return "top_left"
	case WlShellSurfaceResizeBottomLeft:
		return "bottom_left"
	case WlShellSurfaceResizeRight:
		return "right"
	case WlShellSurfaceResizeTopRight:
		return "top_right"
	case WlShellSurfaceResizeBottomRight:
		return "bottom_right"
	default:
		return ""
	}
}
func (e WlShellSurfaceResize) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("resize(%d)", e)
	}
	return fmt.Sprintf("resize(%s)", name)
}

// WlShellSurfaceTransient : details of transient behaviour
//
// These flags specify details of the expected behaviour
// of transient surfaces. Used in the set_transient request.
type WlShellSurfaceTransient uint32

const (
	// WlShellSurfaceTransientInactive : do not set keyboard focus
	WlShellSurfaceTransientInactive WlShellSurfaceTransient = 0x1
)

func (e WlShellSurfaceTransient) Name() string {
	switch e {
	case WlShellSurfaceTransientInactive:
		return "inactive"
	default:
		return ""
	}
}
func (e WlShellSurfaceTransient) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("transient(%d)", e)
	}
	return fmt.Sprintf("transient(%s)", name)
}

// WlShellSurfaceFullscreenMethod : different method to set the surface fullscreen
//
// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type WlShellSurfaceFullscreenMethod uint32

const (
	// WlShellSurfaceFullscreenMethodDefault : no preference, apply default policy
	WlShellSurfaceFullscreenMethodDefault WlShellSurfaceFullscreenMethod = 0
	// WlShellSurfaceFullscreenMethodScale : scale, preserve the surface's aspect ratio and center on output
	WlShellSurfaceFullscreenMethodScale WlShellSurfaceFullscreenMethod = 1
	// WlShellSurfaceFullscreenMethodDriver : switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	WlShellSurfaceFullscreenMethodDriver WlShellSurfaceFullscreenMethod = 2
	// WlShellSurfaceFullscreenMethodFill : no upscaling, center on output and add black borders to compensate size mismatch
	WlShellSurfaceFullscreenMethodFill WlShellSurfaceFullscreenMethod = 3
)

func (e WlShellSurfaceFullscreenMethod) Name() string {
	switch e {
	case WlShellSurfaceFullscreenMethodDefault:
		return "default"
	case WlShellSurfaceFullscreenMethodScale:
		return "scale"
	case WlShellSurfaceFullscreenMethodDriver:
		return "driver"
	case WlShellSurfaceFullscreenMethodFill:
		return "fill"
	default:
		return ""
	}
}
func (e WlShellSurfaceFullscreenMethod) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("fullscreen_method(%d)", e)
	}
	return fmt.Sprintf("fullscreen_method(%s)", name)
}

// WlShellSurfacePingEvent : ping client
//
// Ping a client to check if it is receiving events and sending
// requests. A client is expected to reply with a pong request.
type WlShellSurfacePingEvent struct {
	serial uint32
	proxy  wayland.Proxy
}

// Serial serial number of the ping
func (e *WlShellSurfacePingEvent) Serial() uint32 {
	return e.serial
}

func (e *WlShellSurfacePingEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlShellSurfaceConfigureEvent : suggest resize
//
// The configure event asks the client to resize its surface.
//
// The size is a hint, in the sense that the client is free to
// ignore it if it doesn't resize, pick a smaller size (to
// satisfy aspect ratio or resize in steps of NxM pixels).
//
// The edges parameter provides a hint about how the surface
// was resized. The client may use this information to decide
// how to adjust its content to the new size (e.g. a scrolling
// area might adjust its content position to leave the viewable
// content unmoved).
//
// The client is free to dismiss all but the last configure
// event it received.
//
// The width and height arguments specify the size of the window
// in surface-local coordinates.
type WlShellSurfaceConfigureEvent struct {
	edges  WlShellSurfaceResize
	width  int32
	height int32
	proxy  wayland.Proxy
}

// Edges how the surface was resized
func (e *WlShellSurfaceConfigureEvent) Edges() WlShellSurfaceResize {
	return e.edges
}

// Width new width of the surface
func (e *WlShellSurfaceConfigureEvent) Width() int32 {
	return e.width
}

// Height new height of the surface
func (e *WlShellSurfaceConfigureEvent) Height() int32 {
	return e.height
}

func (e *WlShellSurfaceConfigureEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlShellSurfacePopupDoneEvent : popup interaction is done
//
// The popup_done event is sent out when a popup grab is broken,
// that is, when the user clicks a surface that doesn't belong
// to the client owning the popup surface.
type WlShellSurfacePopupDoneEvent struct {
	proxy wayland.Proxy
}

func (e *WlShellSurfacePopupDoneEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlShellSurface) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlShellSurfacePingEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlShellSurfaceConfigureEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.edges = WlShellSurfaceResize(r.ReadUint())
		e.width = r.ReadInt()
		e.height = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlShellSurfacePopupDoneEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlSurface : an onscreen surface
//
// A surface is a rectangular area that may be displayed on zero
// or more outputs, and shown any number of times at the compositor's
// discretion. They can present wl_buffers, receive user input, and
// define a local coordinate system.
//
// The size of a surface (and relative positions on it) is described
// in surface-local coordinates, which may differ from the buffer
// coordinates of the pixel content, in case a buffer_transform
// or a buffer_scale is used.
//
// A surface without a "role" is fairly useless: a compositor does
// not know where, when or how to present it. The role is the
// purpose of a wl_surface. Examples of roles are a cursor for a
// pointer (as set by wl_pointer.set_cursor), a drag icon
// (wl_data_device.start_drag), a sub-surface
// (wl_subcompositor.get_subsurface), and a window as defined by a
// shell protocol (e.g. wl_shell.get_shell_surface).
//
// A surface can have only one role at a time. Initially a
// wl_surface does not have a role. Once a wl_surface is given a
// role, it is set permanently for the whole lifetime of the
// wl_surface object. Giving the current role again is allowed,
// unless explicitly forbidden by the relevant interface
// specification.
//
// Surface roles are given by requests in other interfaces such as
// wl_pointer.set_cursor. The request should explicitly mention
// that this request gives a role to a wl_surface. Often, this
// request also creates a new protocol object that represents the
// role and adds additional functionality to wl_surface. When a
// client wants to destroy a wl_surface, they must destroy this role
// object before the wl_surface, otherwise a defunct_role_object error is
// sent.
//
// Destroying the role object does not remove the role from the
// wl_surface, but it may stop the wl_surface from "playing the role".
// For instance, if a wl_subsurface object is destroyed, the wl_surface
// it was created for will be unmapped and forget its position and
// z-order. It is allowed to create a wl_subsurface for the same
// wl_surface again, but it is not allowed to use the wl_surface as
// a cursor (cursor is a different role than sub-surface, and role
// switching is not allowed).
type WlSurface struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlSurfaceHandlers struct {
	OnEnter                    wayland.EventHandler
	OnLeave                    wayland.EventHandler
	OnPreferredBufferScale     wayland.EventHandler
	OnPreferredBufferTransform wayland.EventHandler
	Unhandled                  wayland.EventHandler
}

func (h WlSurfaceHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlSurfaceEnterEvent:
		if h.OnEnter != nil && h.OnEnter.Handle(e) {
			return true
		}
	case *WlSurfaceLeaveEvent:
		if h.OnLeave != nil && h.OnLeave.Handle(e) {
			return true
		}
	case *WlSurfacePreferredBufferScaleEvent:
		if h.OnPreferredBufferScale != nil && h.OnPreferredBufferScale.Handle(e) {
			return true
		}
	case *WlSurfacePreferredBufferTransformEvent:
		if h.OnPreferredBufferTransform != nil && h.OnPreferredBufferTransform.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlSurface : an onscreen surface
//
// A surface is a rectangular area that may be displayed on zero
// or more outputs, and shown any number of times at the compositor's
// discretion. They can present wl_buffers, receive user input, and
// define a local coordinate system.
//
// The size of a surface (and relative positions on it) is described
// in surface-local coordinates, which may differ from the buffer
// coordinates of the pixel content, in case a buffer_transform
// or a buffer_scale is used.
//
// A surface without a "role" is fairly useless: a compositor does
// not know where, when or how to present it. The role is the
// purpose of a wl_surface. Examples of roles are a cursor for a
// pointer (as set by wl_pointer.set_cursor), a drag icon
// (wl_data_device.start_drag), a sub-surface
// (wl_subcompositor.get_subsurface), and a window as defined by a
// shell protocol (e.g. wl_shell.get_shell_surface).
//
// A surface can have only one role at a time. Initially a
// wl_surface does not have a role. Once a wl_surface is given a
// role, it is set permanently for the whole lifetime of the
// wl_surface object. Giving the current role again is allowed,
// unless explicitly forbidden by the relevant interface
// specification.
//
// Surface roles are given by requests in other interfaces such as
// wl_pointer.set_cursor. The request should explicitly mention
// that this request gives a role to a wl_surface. Often, this
// request also creates a new protocol object that represents the
// role and adds additional functionality to wl_surface. When a
// client wants to destroy a wl_surface, they must destroy this role
// object before the wl_surface, otherwise a defunct_role_object error is
// sent.
//
// Destroying the role object does not remove the role from the
// wl_surface, but it may stop the wl_surface from "playing the role".
// For instance, if a wl_subsurface object is destroyed, the wl_surface
// it was created for will be unmapped and forget its position and
// z-order. It is allowed to create a wl_subsurface for the same
// wl_surface again, but it is not allowed to use the wl_surface as
// a cursor (cursor is a different role than sub-surface, and role
// switching is not allowed).
func NewWlSurface(handler wayland.EventHandler) *WlSurface {
	return &WlSurface{Handler: handler}
}
func (i *WlSurface) Name() string {
	return "wl_surface"
}

// Destroy : delete surface
//
// Deletes the surface and invalidates its object ID.
func (i *WlSurface) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Attach : set the surface contents
//
// Set a buffer as the content of this surface.
//
// The new size of the surface is calculated based on the buffer
// size transformed by the inverse buffer_transform and the
// inverse buffer_scale. This means that at commit time the supplied
// buffer size must be an integer multiple of the buffer_scale. If
// that's not the case, an invalid_size error is sent.
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes. Setting anything other than 0
// as x and y arguments is discouraged, and should instead be replaced
// with using the separate wl_surface.offset request.
//
// When the bound wl_surface version is 5 or higher, passing any
// non-zero x or y is a protocol violation, and will result in an
// 'invalid_offset' error being raised. The x and y arguments are ignored
// and do not change the pending state. To achieve equivalent semantics,
// use wl_surface.offset.
//
// Surface contents are double-buffered state, see wl_surface.commit.
//
// The initial surface contents are void; there is no content.
// wl_surface.attach assigns the given wl_buffer as the pending
// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
// surface contents, and the size of the surface becomes the size
// calculated from the wl_buffer, as described above. After commit,
// there is no pending buffer until the next attach.
//
// Committing a pending wl_buffer allows the compositor to read the
// pixels in the wl_buffer. The compositor may access the pixels at
// any time after the wl_surface.commit request. When the compositor
// will not access the pixels anymore, it will send the
// wl_buffer.release event. Only after receiving wl_buffer.release,
// the client may reuse the wl_buffer. A wl_buffer that has been
// attached and then replaced by another attach instead of committed
// will not receive a release event, and is not used by the
// compositor.
//
// If a pending wl_buffer has been committed to more than one wl_surface,
// the delivery of wl_buffer.release events becomes undefined. A well
// behaved client should not rely on wl_buffer.release events in this
// case. Alternatively, a client could create multiple wl_buffer objects
// from the same backing storage or use a protocol extension providing
// per-commit release notifications.
//
// Destroying the wl_buffer after wl_buffer.release does not change
// the surface contents. Destroying the wl_buffer before wl_buffer.release
// is allowed as long as the underlying buffer storage isn't re-used (this
// can happen e.g. on client process termination). However, if the client
// destroys the wl_buffer before receiving the wl_buffer.release event and
// mutates the underlying buffer storage, the surface contents become
// undefined immediately.
//
// If wl_surface.attach is sent with a NULL wl_buffer, the
// following wl_surface.commit will remove the surface content.
//
// If a pending wl_buffer has been destroyed, the result is not specified.
// Many compositors are known to remove the surface content on the following
// wl_surface.commit, but this behaviour is not universal. Clients seeking to
// maximise compatibility should not destroy pending buffers and should
// ensure that they explicitly remove content from surfaces, even after
// destroying buffers.
//
// buffer : buffer of surface contents
// x : surface-local x coordinate
// y : surface-local y coordinate
func (i *WlSurface) Attach(buffer *WlBuffer, x int32, y int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if buffer == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(buffer)
	}
	w.WriteInt(x)
	w.WriteInt(y)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Damage : mark part of the surface damaged
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in surface-local coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage adds pending damage: the new pending damage
// is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// Note! New clients should not use this request. Instead damage can be
// posted with wl_surface.damage_buffer which uses buffer coordinates
// instead of surface coordinates.
//
// x : surface-local x coordinate
// y : surface-local y coordinate
// width : width of damage rectangle
// height : height of damage rectangle
func (i *WlSurface) Damage(x int32, y int32, width int32, height int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	w.WriteInt(x)
	w.WriteInt(y)
	w.WriteInt(width)
	w.WriteInt(height)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Frame : request a frame throttling hint
//
// Request a notification when it is a good time to start drawing a new
// frame, by creating a frame callback. This is useful for throttling
// redrawing operations, and driving animations.
//
// When a client is animating on a wl_surface, it can use the 'frame'
// request to get notified when it is a good time to draw and commit the
// next frame of animation. If the client commits an update earlier than
// that, it is likely that some updates will not make it to the display,
// and the client is wasting resources by drawing too often.
//
// The frame request will take effect on the next wl_surface.commit.
// The notification will only be posted for one frame unless
// requested again. For a wl_surface, the notifications are posted in
// the order the frame requests were committed.
//
// The server must send the notifications so that a client
// will not send excessive updates, while still allowing
// the highest possible update rate for clients that wait for the reply
// before drawing again. The server should give some time for the client
// to draw and commit after sending the frame callback events to let it
// hit the next output refresh.
//
// A server should avoid signaling the frame callbacks if the
// surface is not visible in any way, e.g. the surface is off-screen,
// or completely obscured by other opaque surfaces.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the current time, in
// milliseconds, with an undefined base.
//
// callbackHandlers : handler for WlCallback, possible events are WlCallbackDone
func (i *WlSurface) Frame(callbackHandlers wayland.EventHandler) *WlCallback {
	if i == nil || !i.Valid() {
		return nil
	}
	callback := NewWlCallback(callbackHandlers)
	i.Conn().Register(callback)
	i.adjacent = append(i.adjacent, callback)
	w := wayland.NewMessageWriter(i, 3)
	w.WriteObject(callback)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return callback
}

// SetOpaqueRegion : set opaque region
//
// This request sets the region of the surface that contains
// opaque content.
//
// The opaque region is an optimization hint for the compositor
// that lets it optimize the redrawing of content behind opaque
// regions.  Setting an opaque region is not required for correct
// behaviour, but marking transparent content as opaque will result
// in repaint artifacts.
//
// The opaque region is specified in surface-local coordinates.
//
// The compositor ignores the parts of the opaque region that fall
// outside of the surface.
//
// Opaque region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_opaque_region changes the pending opaque region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise, the pending and current regions are never changed.
//
// The initial value for an opaque region is empty. Setting the pending
// opaque region has copy semantics, and the wl_region object can be
// destroyed immediately. A NULL wl_region causes the pending opaque
// region to be set to empty.
//
// region : opaque region of the surface
func (i *WlSurface) SetOpaqueRegion(region *WlRegion) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 4)
	if region == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(region)
	}
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetInputRegion : set input region
//
// This request sets the region of the surface that can receive
// pointer and touch events.
//
// Input events happening outside of this region will try the next
// surface in the server surface stack. The compositor ignores the
// parts of the input region that fall outside of the surface.
//
// The input region is specified in surface-local coordinates.
//
// Input region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_input_region changes the pending input region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise the pending and current regions are never changed,
// except cursor and icon surfaces are special cases, see
// wl_pointer.set_cursor and wl_data_device.start_drag.
//
// The initial value for an input region is infinite. That means the
// whole surface will accept input. Setting the pending input region
// has copy semantics, and the wl_region object can be destroyed
// immediately. A NULL wl_region causes the input region to be set
// to infinite.
//
// region : input region of the surface
func (i *WlSurface) SetInputRegion(region *WlRegion) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 5)
	if region == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(region)
	}
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Commit : commit pending surface state
//
// Surface state (input, opaque, and damage regions, attached buffers,
// etc.) is double-buffered. Protocol requests modify the pending state,
// as opposed to the active state in use by the compositor.
//
// A commit request atomically creates a content update from the pending
// state, even if the pending state has not been touched. The content
// update is placed in a queue until it becomes active. After commit, the
// new pending state is as documented for each related request.
//
// When the content update is applied, the wl_buffer is applied before all
// other state. This means that all coordinates in double-buffered state
// are relative to the newly attached wl_buffers, except for
// wl_surface.attach itself. If there is no newly attached wl_buffer, the
// coordinates are relative to the previous content update.
//
// All requests that need a commit to become effective are documented
// to affect double-buffered state.
//
// Other interfaces may add further double-buffered surface state.
func (i *WlSurface) Commit() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 6)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetBufferTransform : sets the buffer transformation
//
// This request sets the transformation that the client has already applied
// to the content of the buffer. The accepted values for the transform
// parameter are the values for wl_output.transform.
//
// The compositor applies the inverse of this transformation whenever it
// uses the buffer contents.
//
// Buffer transform is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer transformation set to normal.
//
// wl_surface.set_buffer_transform changes the pending buffer
// transformation. wl_surface.commit copies the pending buffer
// transformation to the current one. Otherwise, the pending and current
// values are never changed.
//
// The purpose of this request is to allow clients to render content
// according to the output transform, thus permitting the compositor to
// use certain optimizations even if the display is rotated. Using
// hardware overlays and scanning out a client buffer for fullscreen
// surfaces are examples of such optimizations. Those optimizations are
// highly dependent on the compositor implementation, so the use of this
// request should be considered on a case-by-case basis.
//
// Note that if the transform value includes 90 or 270 degree rotation,
// the width of the buffer will become the surface height and the height
// of the buffer will become the surface width.
//
// If transform is not one of the values from the
// wl_output.transform enum the invalid_transform protocol error
// is raised.
//
// transform : transform for interpreting buffer contents
func (i *WlSurface) SetBufferTransform(transform int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 7)
	w.WriteInt(transform)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetBufferScale : sets the buffer scaling factor
//
// This request sets an optional scaling factor on how the compositor
// interprets the contents of the buffer attached to the window.
//
// Buffer scale is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer scale set to 1.
//
// wl_surface.set_buffer_scale changes the pending buffer scale.
// wl_surface.commit copies the pending buffer scale to the current one.
// Otherwise, the pending and current values are never changed.
//
// The purpose of this request is to allow clients to supply higher
// resolution buffer data for use on high resolution outputs. It is
// intended that you pick the same buffer scale as the scale of the
// output that the surface is displayed on. This means the compositor
// can avoid scaling when rendering the surface on that output.
//
// Note that if the scale is larger than 1, then you have to attach
// a buffer that is larger (by a factor of scale in each dimension)
// than the desired surface size.
//
// If scale is not greater than 0 the invalid_scale protocol error is
// raised.
//
// scale : scale for interpreting buffer contents
func (i *WlSurface) SetBufferScale(scale int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 8)
	w.WriteInt(scale)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// DamageBuffer : mark part of the surface damaged using buffer coordinates
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in buffer coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage_buffer adds pending damage: the new pending
// damage is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// This request differs from wl_surface.damage in only one way - it
// takes damage in buffer coordinates instead of surface-local
// coordinates. While this generally is more intuitive than surface
// coordinates, it is especially desirable when using wp_viewport
// or when a drawing library (like EGL) is unaware of buffer scale
// and buffer transform.
//
// Note: Because buffer transformation changes and damage requests may
// be interleaved in the protocol stream, it is impossible to determine
// the actual mapping between surface and buffer damage until
// wl_surface.commit time. Therefore, compositors wishing to take both
// kinds of damage into account will have to accumulate damage from the
// two requests separately and only transform from one to the other
// after receiving the wl_surface.commit.
//
// x : buffer-local x coordinate
// y : buffer-local y coordinate
// width : width of damage rectangle
// height : height of damage rectangle
func (i *WlSurface) DamageBuffer(x int32, y int32, width int32, height int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 9)
	w.WriteInt(x)
	w.WriteInt(y)
	w.WriteInt(width)
	w.WriteInt(height)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Offset : set the surface contents offset
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes.
//
// The exact semantics of wl_surface.offset are role-specific. Refer to
// the documentation of specific roles for more information.
//
// Surface location offset is double-buffered state, see
// wl_surface.commit.
//
// This request is semantically equivalent to and the replaces the x and y
// arguments in the wl_surface.attach request in wl_surface versions prior
// to 5. See wl_surface.attach for details.
//
// x : surface-local x coordinate
// y : surface-local y coordinate
func (i *WlSurface) Offset(x int32, y int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 10)
	w.WriteInt(x)
	w.WriteInt(y)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlSurfaceError : wl_surface error values
//
// These errors can be emitted in response to wl_surface requests.
type WlSurfaceError uint32

const (
	// WlSurfaceErrorInvalidScale : buffer scale value is invalid
	WlSurfaceErrorInvalidScale WlSurfaceError = 0
	// WlSurfaceErrorInvalidTransform : buffer transform value is invalid
	WlSurfaceErrorInvalidTransform WlSurfaceError = 1
	// WlSurfaceErrorInvalidSize : buffer size is invalid
	WlSurfaceErrorInvalidSize WlSurfaceError = 2
	// WlSurfaceErrorInvalidOffset : buffer offset is invalid
	WlSurfaceErrorInvalidOffset WlSurfaceError = 3
	// WlSurfaceErrorDefunctRoleObject : surface was destroyed before its role object
	WlSurfaceErrorDefunctRoleObject WlSurfaceError = 4
)

func (e WlSurfaceError) Name() string {
	switch e {
	case WlSurfaceErrorInvalidScale:
		return "invalid_scale"
	case WlSurfaceErrorInvalidTransform:
		return "invalid_transform"
	case WlSurfaceErrorInvalidSize:
		return "invalid_size"
	case WlSurfaceErrorInvalidOffset:
		return "invalid_offset"
	case WlSurfaceErrorDefunctRoleObject:
		return "defunct_role_object"
	default:
		return ""
	}
}
func (e WlSurfaceError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlSurfaceEnterEvent : surface enters an output
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in some part of it being within the scanout region of an
// output.
//
// Note that a surface may be overlapping with zero or more outputs.
type WlSurfaceEnterEvent struct {
	output *WlOutput
	proxy  wayland.Proxy
}

// Output output entered by the surface
func (e *WlSurfaceEnterEvent) Output() *WlOutput {
	return e.output
}

func (e *WlSurfaceEnterEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlSurfaceLeaveEvent : surface leaves an output
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in it no longer having any part of it within the scanout region
// of an output.
//
// Clients should not use the number of outputs the surface is on for frame
// throttling purposes. The surface might be hidden even if no leave event
// has been sent, and the compositor might expect new surface content
// updates even if no enter event has been sent. The frame event should be
// used instead.
type WlSurfaceLeaveEvent struct {
	output *WlOutput
	proxy  wayland.Proxy
}

// Output output left by the surface
func (e *WlSurfaceLeaveEvent) Output() *WlOutput {
	return e.output
}

func (e *WlSurfaceLeaveEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlSurfacePreferredBufferScaleEvent : preferred buffer scale for the surface
//
// This event indicates the preferred buffer scale for this surface. It is
// sent whenever the compositor's preference changes.
//
// Before receiving this event the preferred buffer scale for this surface
// is 1.
//
// It is intended that scaling aware clients use this event to scale their
// content and use wl_surface.set_buffer_scale to indicate the scale they
// have rendered with. This allows clients to supply a higher detail
// buffer.
//
// The compositor shall emit a scale value greater than 0.
type WlSurfacePreferredBufferScaleEvent struct {
	factor int32
	proxy  wayland.Proxy
}

// Factor preferred scaling factor
func (e *WlSurfacePreferredBufferScaleEvent) Factor() int32 {
	return e.factor
}

func (e *WlSurfacePreferredBufferScaleEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlSurfacePreferredBufferTransformEvent : preferred buffer transform for the surface
//
// This event indicates the preferred buffer transform for this surface.
// It is sent whenever the compositor's preference changes.
//
// Before receiving this event the preferred buffer transform for this
// surface is normal.
//
// Applying this transformation to the surface buffer contents and using
// wl_surface.set_buffer_transform might allow the compositor to use the
// surface buffer more efficiently.
type WlSurfacePreferredBufferTransformEvent struct {
	transform WlOutputTransform
	proxy     wayland.Proxy
}

// Transform preferred transform
func (e *WlSurfacePreferredBufferTransformEvent) Transform() WlOutputTransform {
	return e.transform
}

func (e *WlSurfacePreferredBufferTransformEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlSurface) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlSurfaceEnterEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		output := r.ReadObject()
		if output != nil {
			e.output = output.(*WlOutput)
		}
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlSurfaceLeaveEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		output := r.ReadObject()
		if output != nil {
			e.output = output.(*WlOutput)
		}
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlSurfacePreferredBufferScaleEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.factor = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlSurfacePreferredBufferTransformEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.transform = WlOutputTransform(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlSeat : group of input devices
//
// A seat is a group of keyboards, pointer and touch devices. This
// object is published as a global during start up, or when such a
// device is hot plugged.  A seat typically has a pointer and
// maintains a keyboard focus and a pointer focus.
type WlSeat struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlSeatHandlers struct {
	OnCapabilities wayland.EventHandler
	OnName         wayland.EventHandler
	Unhandled      wayland.EventHandler
}

func (h WlSeatHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlSeatCapabilitiesEvent:
		if h.OnCapabilities != nil && h.OnCapabilities.Handle(e) {
			return true
		}
	case *WlSeatNameEvent:
		if h.OnName != nil && h.OnName.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlSeat : group of input devices
//
// A seat is a group of keyboards, pointer and touch devices. This
// object is published as a global during start up, or when such a
// device is hot plugged.  A seat typically has a pointer and
// maintains a keyboard focus and a pointer focus.
func NewWlSeat(handler wayland.EventHandler) *WlSeat {
	return &WlSeat{Handler: handler}
}
func (i *WlSeat) Name() string {
	return "wl_seat"
}

// GetPointer : return pointer object
//
// The ID provided will be initialized to the wl_pointer interface
// for this seat.
//
// This request only takes effect if the seat has the pointer
// capability, or has had the pointer capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the pointer capability. The missing_capability error will
// be sent in this case.
//
// idHandlers : handler for WlPointer, possible events are WlPointerEnter, WlPointerLeave, WlPointerMotion, WlPointerButton, WlPointerAxis, WlPointerFrame, WlPointerAxisSource, WlPointerAxisStop, WlPointerAxisDiscrete, WlPointerAxisValue120, WlPointerAxisRelativeDirection
func (i *WlSeat) GetPointer(idHandlers wayland.EventHandler) *WlPointer {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlPointer(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// GetKeyboard : return keyboard object
//
// The ID provided will be initialized to the wl_keyboard interface
// for this seat.
//
// This request only takes effect if the seat has the keyboard
// capability, or has had the keyboard capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the keyboard capability. The missing_capability error will
// be sent in this case.
//
// idHandlers : handler for WlKeyboard, possible events are WlKeyboardKeymap, WlKeyboardEnter, WlKeyboardLeave, WlKeyboardKey, WlKeyboardModifiers, WlKeyboardRepeatInfo
func (i *WlSeat) GetKeyboard(idHandlers wayland.EventHandler) *WlKeyboard {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlKeyboard(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// GetTouch : return touch object
//
// The ID provided will be initialized to the wl_touch interface
// for this seat.
//
// This request only takes effect if the seat has the touch
// capability, or has had the touch capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the touch capability. The missing_capability error will
// be sent in this case.
//
// idHandlers : handler for WlTouch, possible events are WlTouchDown, WlTouchUp, WlTouchMotion, WlTouchFrame, WlTouchCancel, WlTouchShape, WlTouchOrientation
func (i *WlSeat) GetTouch(idHandlers wayland.EventHandler) *WlTouch {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlTouch(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 2)
	w.WriteObject(id)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// Release : release the seat object
//
// Using this request a client can tell the server that it is not going to
// use the seat object anymore.
func (i *WlSeat) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 3)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlSeat) Destroy() {
	i.Release()
}

// WlSeatCapability : seat capability bitmask
//
// This is a bitmask of capabilities this seat has; if a member is
// set, then it is present on the seat.
type WlSeatCapability uint32

const (
	// WlSeatCapabilityPointer : the seat has pointer devices
	WlSeatCapabilityPointer WlSeatCapability = 1
	// WlSeatCapabilityKeyboard : the seat has one or more keyboards
	WlSeatCapabilityKeyboard WlSeatCapability = 2
	// WlSeatCapabilityTouch : the seat has touch devices
	WlSeatCapabilityTouch WlSeatCapability = 4
)

func (e WlSeatCapability) Name() string {
	switch e {
	case WlSeatCapabilityPointer:
		return "pointer"
	case WlSeatCapabilityKeyboard:
		return "keyboard"
	case WlSeatCapabilityTouch:
		return "touch"
	default:
		return ""
	}
}
func (e WlSeatCapability) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("capability(%d)", e)
	}
	return fmt.Sprintf("capability(%s)", name)
}

// WlSeatError : wl_seat error values
//
// These errors can be emitted in response to wl_seat requests.
type WlSeatError uint32

const (
	// WlSeatErrorMissingCapability : get_pointer, get_keyboard or get_touch called on seat without the matching capability
	WlSeatErrorMissingCapability WlSeatError = 0
)

func (e WlSeatError) Name() string {
	switch e {
	case WlSeatErrorMissingCapability:
		return "missing_capability"
	default:
		return ""
	}
}
func (e WlSeatError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlSeatCapabilitiesEvent : seat capabilities changed
//
// This is sent on binding to the seat global or whenever a seat gains
// or loses the pointer, keyboard or touch capabilities.
// The argument is a capability enum containing the complete set of
// capabilities this seat has.
//
// When the pointer capability is added, a client may create a
// wl_pointer object using the wl_seat.get_pointer request. This object
// will receive pointer events until the capability is removed in the
// future.
//
// When the pointer capability is removed, a client should destroy the
// wl_pointer objects associated with the seat where the capability was
// removed, using the wl_pointer.release request. No further pointer
// events will be received on these objects.
//
// In some compositors, if a seat regains the pointer capability and a
// client has a previously obtained wl_pointer object of version 4 or
// less, that object may start sending pointer events again. This
// behavior is considered a misinterpretation of the intended behavior
// and must not be relied upon by the client. wl_pointer objects of
// version 5 or later must not send events if created before the most
// recent event notifying the client of an added pointer capability.
//
// The above behavior also applies to wl_keyboard and wl_touch with the
// keyboard and touch capabilities, respectively.
type WlSeatCapabilitiesEvent struct {
	capabilities WlSeatCapability
	proxy        wayland.Proxy
}

// Capabilities capabilities of the seat
func (e *WlSeatCapabilitiesEvent) Capabilities() WlSeatCapability {
	return e.capabilities
}

func (e *WlSeatCapabilitiesEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlSeatNameEvent : unique identifier for this seat
//
// In a multi-seat configuration the seat name can be used by clients to
// help identify which physical devices the seat represents.
//
// The seat name is a UTF-8 string with no convention defined for its
// contents. Each name is unique among all wl_seat globals. The name is
// only guaranteed to be unique for the current compositor instance.
//
// The same seat names are used for all clients. Thus, the name can be
// shared across processes to refer to a specific wl_seat global.
//
// The name event is sent after binding to the seat global, and should be sent
// before announcing capabilities. This event only sent once per seat object,
// and the name does not change over the lifetime of the wl_seat global.
//
// Compositors may re-use the same seat name if the wl_seat global is
// destroyed and re-created later.
type WlSeatNameEvent struct {
	name  string
	proxy wayland.Proxy
}

// Name seat identifier
func (e *WlSeatNameEvent) Name() string {
	return e.name
}

func (e *WlSeatNameEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlSeat) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlSeatCapabilitiesEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.capabilities = WlSeatCapability(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlSeatNameEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.name = r.ReadString()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlPointer : pointer input device
//
// The wl_pointer interface represents one or more input devices,
// such as mice, which control the pointer location and pointer_focus
// of a seat.
//
// The wl_pointer interface generates motion, enter and leave
// events for the surfaces that the pointer is located over,
// and button and axis events for button presses, button releases
// and scrolling.
type WlPointer struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlPointerHandlers struct {
	OnEnter                 wayland.EventHandler
	OnLeave                 wayland.EventHandler
	OnMotion                wayland.EventHandler
	OnButton                wayland.EventHandler
	OnAxis                  wayland.EventHandler
	OnFrame                 wayland.EventHandler
	OnAxisSource            wayland.EventHandler
	OnAxisStop              wayland.EventHandler
	OnAxisDiscrete          wayland.EventHandler
	OnAxisValue120          wayland.EventHandler
	OnAxisRelativeDirection wayland.EventHandler
	Unhandled               wayland.EventHandler
}

func (h WlPointerHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlPointerEnterEvent:
		if h.OnEnter != nil && h.OnEnter.Handle(e) {
			return true
		}
	case *WlPointerLeaveEvent:
		if h.OnLeave != nil && h.OnLeave.Handle(e) {
			return true
		}
	case *WlPointerMotionEvent:
		if h.OnMotion != nil && h.OnMotion.Handle(e) {
			return true
		}
	case *WlPointerButtonEvent:
		if h.OnButton != nil && h.OnButton.Handle(e) {
			return true
		}
	case *WlPointerAxisEvent:
		if h.OnAxis != nil && h.OnAxis.Handle(e) {
			return true
		}
	case *WlPointerFrameEvent:
		if h.OnFrame != nil && h.OnFrame.Handle(e) {
			return true
		}
	case *WlPointerAxisSourceEvent:
		if h.OnAxisSource != nil && h.OnAxisSource.Handle(e) {
			return true
		}
	case *WlPointerAxisStopEvent:
		if h.OnAxisStop != nil && h.OnAxisStop.Handle(e) {
			return true
		}
	case *WlPointerAxisDiscreteEvent:
		if h.OnAxisDiscrete != nil && h.OnAxisDiscrete.Handle(e) {
			return true
		}
	case *WlPointerAxisValue120Event:
		if h.OnAxisValue120 != nil && h.OnAxisValue120.Handle(e) {
			return true
		}
	case *WlPointerAxisRelativeDirectionEvent:
		if h.OnAxisRelativeDirection != nil && h.OnAxisRelativeDirection.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlPointer : pointer input device
//
// The wl_pointer interface represents one or more input devices,
// such as mice, which control the pointer location and pointer_focus
// of a seat.
//
// The wl_pointer interface generates motion, enter and leave
// events for the surfaces that the pointer is located over,
// and button and axis events for button presses, button releases
// and scrolling.
func NewWlPointer(handler wayland.EventHandler) *WlPointer {
	return &WlPointer{Handler: handler}
}
func (i *WlPointer) Name() string {
	return "wl_pointer"
}

// SetCursor : set the pointer surface
//
// Set the pointer surface, i.e., the surface that contains the
// pointer image (cursor). This request gives the surface the role
// of a cursor. If the surface already has another role, it raises
// a protocol error.
//
// The cursor actually changes only if the pointer
// focus for this device is one of the requesting client's surfaces
// or the surface parameter is the current pointer surface. If
// there was a previous surface set with this request it is
// replaced. If surface is NULL, the pointer image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of
// the pointer surface relative to the pointer location. Its
// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
// where (x, y) are the coordinates of the pointer location, in
// surface-local coordinates.
//
// On wl_surface.offset requests to the pointer surface, hotspot_x
// and hotspot_y are decremented by the x and y parameters
// passed to the request. The offset must be applied by
// wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set
// pointer surface to this request with new values for hotspot_x
// and hotspot_y.
//
// The input region is ignored for wl_surfaces with the role of
// a cursor. When the use as a cursor ends, the wl_surface is
// unmapped.
//
// The serial parameter must match the latest wl_pointer.enter
// serial number sent to the client. Otherwise the request will be
// ignored.
//
// serial : serial number of the enter event
// surface : pointer surface
// hotspotX : surface-local x coordinate
// hotspotY : surface-local y coordinate
func (i *WlPointer) SetCursor(serial uint32, surface *WlSurface, hotspotX int32, hotspotY int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	w.WriteUint(uint32(serial))
	if surface == nil {
		w.WriteUint(0)
	} else {
		w.WriteObject(surface)
	}
	w.WriteInt(hotspotX)
	w.WriteInt(hotspotY)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Release : release the pointer object
//
// Using this request a client can tell the server that it is not going to
// use the pointer object anymore.
//
// This request destroys the pointer proxy object, so clients must not call
// wl_pointer_destroy() after using this request.
func (i *WlPointer) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlPointer) Destroy() {
	i.Release()
}

// WlPointerError :
type WlPointerError uint32

const (
	// WlPointerErrorRole : given wl_surface has another role
	WlPointerErrorRole WlPointerError = 0
)

func (e WlPointerError) Name() string {
	switch e {
	case WlPointerErrorRole:
		return "role"
	default:
		return ""
	}
}
func (e WlPointerError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlPointerButtonState : physical button state
//
// Describes the physical state of a button that produced the button
// event.
type WlPointerButtonState uint32

const (
	// WlPointerButtonStateReleased : the button is not pressed
	WlPointerButtonStateReleased WlPointerButtonState = 0
	// WlPointerButtonStatePressed : the button is pressed
	WlPointerButtonStatePressed WlPointerButtonState = 1
)

func (e WlPointerButtonState) Name() string {
	switch e {
	case WlPointerButtonStateReleased:
		return "released"
	case WlPointerButtonStatePressed:
		return "pressed"
	default:
		return ""
	}
}
func (e WlPointerButtonState) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("button_state(%d)", e)
	}
	return fmt.Sprintf("button_state(%s)", name)
}

// WlPointerAxis : axis types
//
// Describes the axis types of scroll events.
type WlPointerAxis uint32

const (
	// WlPointerAxisVerticalScroll : vertical axis
	WlPointerAxisVerticalScroll WlPointerAxis = 0
	// WlPointerAxisHorizontalScroll : horizontal axis
	WlPointerAxisHorizontalScroll WlPointerAxis = 1
)

func (e WlPointerAxis) Name() string {
	switch e {
	case WlPointerAxisVerticalScroll:
		return "vertical_scroll"
	case WlPointerAxisHorizontalScroll:
		return "horizontal_scroll"
	default:
		return ""
	}
}
func (e WlPointerAxis) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("axis(%d)", e)
	}
	return fmt.Sprintf("axis(%s)", name)
}

// WlPointerAxisSource : axis source types
//
// Describes the source types for axis events. This indicates to the
// client how an axis event was physically generated; a client may
// adjust the user interface accordingly. For example, scroll events
// from a "finger" source may be in a smooth coordinate space with
// kinetic scrolling whereas a "wheel" source may be in discrete steps
// of a number of lines.
//
// The "continuous" axis source is a device generating events in a
// continuous coordinate space, but using something other than a
// finger. One example for this source is button-based scrolling where
// the vertical motion of a device is converted to scroll events while
// a button is held down.
//
// The "wheel tilt" axis source indicates that the actual device is a
// wheel but the scroll event is not caused by a rotation but a
// (usually sideways) tilt of the wheel.
type WlPointerAxisSource uint32

const (
	// WlPointerAxisSourceWheel : a physical wheel rotation
	WlPointerAxisSourceWheel WlPointerAxisSource = 0
	// WlPointerAxisSourceFinger : finger on a touch surface
	WlPointerAxisSourceFinger WlPointerAxisSource = 1
	// WlPointerAxisSourceContinuous : continuous coordinate space
	WlPointerAxisSourceContinuous WlPointerAxisSource = 2
	// WlPointerAxisSourceWheelTilt : a physical wheel tilt
	WlPointerAxisSourceWheelTilt WlPointerAxisSource = 3
)

func (e WlPointerAxisSource) Name() string {
	switch e {
	case WlPointerAxisSourceWheel:
		return "wheel"
	case WlPointerAxisSourceFinger:
		return "finger"
	case WlPointerAxisSourceContinuous:
		return "continuous"
	case WlPointerAxisSourceWheelTilt:
		return "wheel_tilt"
	default:
		return ""
	}
}
func (e WlPointerAxisSource) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("axis_source(%d)", e)
	}
	return fmt.Sprintf("axis_source(%s)", name)
}

// WlPointerAxisRelativeDirection : axis relative direction
//
// This specifies the direction of the physical motion that caused a
// wl_pointer.axis event, relative to the wl_pointer.axis direction.
type WlPointerAxisRelativeDirection uint32

const (
	// WlPointerAxisRelativeDirectionIdentical : physical motion matches axis direction
	WlPointerAxisRelativeDirectionIdentical WlPointerAxisRelativeDirection = 0
	// WlPointerAxisRelativeDirectionInverted : physical motion is the inverse of the axis direction
	WlPointerAxisRelativeDirectionInverted WlPointerAxisRelativeDirection = 1
)

func (e WlPointerAxisRelativeDirection) Name() string {
	switch e {
	case WlPointerAxisRelativeDirectionIdentical:
		return "identical"
	case WlPointerAxisRelativeDirectionInverted:
		return "inverted"
	default:
		return ""
	}
}
func (e WlPointerAxisRelativeDirection) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("axis_relative_direction(%d)", e)
	}
	return fmt.Sprintf("axis_relative_direction(%s)", name)
}

// WlPointerEnterEvent : enter event
//
// Notification that this seat's pointer is focused on a certain
// surface.
//
// When a seat's focus enters a surface, the pointer image
// is undefined and a client should respond to this event by setting
// an appropriate pointer image with the set_cursor request.
type WlPointerEnterEvent struct {
	serial   uint32
	surface  *WlSurface
	surfaceX float64
	surfaceY float64
	proxy    wayland.Proxy
}

// Serial serial number of the enter event
func (e *WlPointerEnterEvent) Serial() uint32 {
	return e.serial
}

// Surface surface entered by the pointer
func (e *WlPointerEnterEvent) Surface() *WlSurface {
	return e.surface
}

// SurfaceX surface-local x coordinate
func (e *WlPointerEnterEvent) SurfaceX() float64 {
	return e.surfaceX
}

// SurfaceY surface-local y coordinate
func (e *WlPointerEnterEvent) SurfaceY() float64 {
	return e.surfaceY
}

func (e *WlPointerEnterEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerLeaveEvent : leave event
//
// Notification that this seat's pointer is no longer focused on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
type WlPointerLeaveEvent struct {
	serial  uint32
	surface *WlSurface
	proxy   wayland.Proxy
}

// Serial serial number of the leave event
func (e *WlPointerLeaveEvent) Serial() uint32 {
	return e.serial
}

// Surface surface left by the pointer
func (e *WlPointerLeaveEvent) Surface() *WlSurface {
	return e.surface
}

func (e *WlPointerLeaveEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerMotionEvent : pointer motion event
//
// Notification of pointer location change. The arguments
// surface_x and surface_y are the location relative to the
// focused surface.
type WlPointerMotionEvent struct {
	time     uint32
	surfaceX float64
	surfaceY float64
	proxy    wayland.Proxy
}

// Time timestamp with millisecond granularity
func (e *WlPointerMotionEvent) Time() uint32 {
	return e.time
}

// SurfaceX surface-local x coordinate
func (e *WlPointerMotionEvent) SurfaceX() float64 {
	return e.surfaceX
}

// SurfaceY surface-local y coordinate
func (e *WlPointerMotionEvent) SurfaceY() float64 {
	return e.surfaceY
}

func (e *WlPointerMotionEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerButtonEvent : pointer button event
//
// Mouse button click and release notifications.
//
// The location of the click is given by the last motion or
// enter event.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The button is a button code as defined in the Linux kernel's
// linux/input-event-codes.h header file, e.g. BTN_LEFT.
//
// Any 16-bit button code value is reserved for future additions to the
// kernel's event code list. All other button codes above 0xFFFF are
// currently undefined but may be used in future versions of this
// protocol.
type WlPointerButtonEvent struct {
	serial uint32
	time   uint32
	button uint32
	state  WlPointerButtonState
	proxy  wayland.Proxy
}

// Serial serial number of the button event
func (e *WlPointerButtonEvent) Serial() uint32 {
	return e.serial
}

// Time timestamp with millisecond granularity
func (e *WlPointerButtonEvent) Time() uint32 {
	return e.time
}

// Button button that produced the event
func (e *WlPointerButtonEvent) Button() uint32 {
	return e.button
}

// State physical state of the button
func (e *WlPointerButtonEvent) State() WlPointerButtonState {
	return e.state
}

func (e *WlPointerButtonEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerAxisEvent : axis event
//
// Scroll and other axis notifications.
//
// For scroll events (vertical and horizontal scroll axes), the
// value parameter is the length of a vector along the specified
// axis in a coordinate space identical to those of motion events,
// representing a relative movement along the specified axis.
//
// For devices that support movements non-parallel to axes multiple
// axis events will be emitted.
//
// When applicable, for example for touch pads, the server can
// choose to emit scroll events where the motion vector is
// equivalent to a motion event vector.
//
// When applicable, a client can transform its content relative to the
// scroll distance.
type WlPointerAxisEvent struct {
	time  uint32
	axis  WlPointerAxis
	value float64
	proxy wayland.Proxy
}

// Time timestamp with millisecond granularity
func (e *WlPointerAxisEvent) Time() uint32 {
	return e.time
}

// Axis axis type
func (e *WlPointerAxisEvent) Axis() WlPointerAxis {
	return e.axis
}

// Value length of vector in surface-local coordinate space
func (e *WlPointerAxisEvent) Value() float64 {
	return e.value
}

func (e *WlPointerAxisEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerFrameEvent : end of a pointer event sequence
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// All wl_pointer events before a wl_pointer.frame event belong
// logically together. For example, in a diagonal scroll motion the
// compositor will send an optional wl_pointer.axis_source event, two
// wl_pointer.axis events (horizontal and vertical) and finally a
// wl_pointer.frame event. The client may use this information to
// calculate a diagonal vector for scrolling.
//
// When multiple wl_pointer.axis events occur within the same frame,
// the motion vector is the combined motion of all events.
// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
// the same frame, this indicates that axis movement in one axis has
// stopped but continues in the other axis.
// When multiple wl_pointer.axis_stop events occur within the same
// frame, this indicates that these axes stopped in the same instance.
//
// A wl_pointer.frame event is sent for every logical event group,
// even if the group only contains a single wl_pointer event.
// Specifically, a client may get a sequence: motion, frame, button,
// frame, axis, frame, axis_stop, frame.
//
// The wl_pointer.enter and wl_pointer.leave events are logical events
// generated by the compositor and not the hardware. These events are
// also grouped by a wl_pointer.frame. When a pointer moves from one
// surface to another, a compositor should group the
// wl_pointer.leave event within the same wl_pointer.frame.
// However, a client must not rely on wl_pointer.leave and
// wl_pointer.enter being in the same wl_pointer.frame.
// Compositor-specific policies may require the wl_pointer.leave and
// wl_pointer.enter event being split across multiple wl_pointer.frame
// groups.
type WlPointerFrameEvent struct {
	proxy wayland.Proxy
}

func (e *WlPointerFrameEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerAxisSourceEvent : axis source event
//
// Source information for scroll and other axes.
//
// This event does not occur on its own. It is sent before a
// wl_pointer.frame event and carries the source information for
// all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
// sent when the user lifts the finger off the device.
//
// If the source is wl_pointer.axis_source.wheel,
// wl_pointer.axis_source.wheel_tilt or
// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
// or may not be sent. Whether a compositor sends an axis_stop event
// for these sources is hardware-specific and implementation-dependent;
// clients must not rely on receiving an axis_stop event for these
// scroll sources and should treat scroll sequences from these scroll
// sources as unterminated by default.
//
// This event is optional. If the source is unknown for a particular
// axis event sequence, no event is sent.
// Only one wl_pointer.axis_source event is permitted per frame.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisSourceEvent struct {
	axisSource WlPointerAxisSource
	proxy      wayland.Proxy
}

// AxisSource source of the axis event
func (e *WlPointerAxisSourceEvent) AxisSource() WlPointerAxisSource {
	return e.axisSource
}

func (e *WlPointerAxisSourceEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerAxisStopEvent : axis stop event
//
// Stop notification for scroll and other axes.
//
// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
// is sent to notify a client that the axis sequence has terminated.
// This enables the client to implement kinetic scrolling.
// See the wl_pointer.axis_source documentation for information on when
// this event may be generated.
//
// Any wl_pointer.axis events with the same axis_source after this
// event should be considered as the start of a new axis motion.
//
// The timestamp is to be interpreted identical to the timestamp in the
// wl_pointer.axis event. The timestamp value may be the same as a
// preceding wl_pointer.axis event.
type WlPointerAxisStopEvent struct {
	time  uint32
	axis  WlPointerAxis
	proxy wayland.Proxy
}

// Time timestamp with millisecond granularity
func (e *WlPointerAxisStopEvent) Time() uint32 {
	return e.time
}

// Axis the axis stopped with this event
func (e *WlPointerAxisStopEvent) Axis() WlPointerAxis {
	return e.axis
}

func (e *WlPointerAxisStopEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerAxisDiscreteEvent : axis click event
//
// Discrete step information for scroll and other axes.
//
// This event carries the axis value of the wl_pointer.axis event in
// discrete steps (e.g. mouse wheel clicks).
//
// This event is deprecated with wl_pointer version 8 - this event is not
// sent to clients supporting version 8 or later.
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value on a
// continuous scale. The protocol guarantees that each axis_discrete
// event is always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_discrete and
// its coupled axis event, including other axis_discrete or axis
// events. A wl_pointer.frame must not contain more than one axis_discrete
// event per axis type.
//
// This event is optional; continuous scrolling devices
// like two-finger scrolling on touchpads do not have discrete
// steps and do not generate this event.
//
// The discrete value carries the directional information. e.g. a value
// of -2 is two steps towards the negative direction of this axis.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisDiscreteEvent struct {
	axis     WlPointerAxis
	discrete int32
	proxy    wayland.Proxy
}

// Axis axis type
func (e *WlPointerAxisDiscreteEvent) Axis() WlPointerAxis {
	return e.axis
}

// Discrete number of steps
func (e *WlPointerAxisDiscreteEvent) Discrete() int32 {
	return e.discrete
}

func (e *WlPointerAxisDiscreteEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerAxisValue120Event : axis high-resolution scroll event
//
// Discrete high-resolution scroll information.
//
// This event carries high-resolution wheel scroll information,
// with each multiple of 120 representing one logical scroll step
// (a wheel detent). For example, an axis_value120 of 30 is one quarter of
// a logical scroll step in the positive direction, a value120 of
// -240 are two logical scroll steps in the negative direction within the
// same hardware event.
// Clients that rely on discrete scrolling should accumulate the
// value120 to multiples of 120 before processing the event.
//
// The value120 must not be zero.
//
// This event replaces the wl_pointer.axis_discrete event in clients
// supporting wl_pointer version 8 or later.
//
// Where a wl_pointer.axis_source event occurs in the same
// wl_pointer.frame, the axis source applies to this event.
//
// The order of wl_pointer.axis_value120 and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisValue120Event struct {
	axis     WlPointerAxis
	value120 int32
	proxy    wayland.Proxy
}

// Axis axis type
func (e *WlPointerAxisValue120Event) Axis() WlPointerAxis {
	return e.axis
}

// Value120 scroll distance as fraction of 120
func (e *WlPointerAxisValue120Event) Value120() int32 {
	return e.value120
}

func (e *WlPointerAxisValue120Event) Proxy() wayland.Proxy {
	return e.proxy
}

// WlPointerAxisRelativeDirectionEvent : axis relative physical direction event
//
// Relative directional information of the entity causing the axis
// motion.
//
// For a wl_pointer.axis event, the wl_pointer.axis_relative_direction
// event specifies the movement direction of the entity causing the
// wl_pointer.axis event. For example:
// - if a user's fingers on a touchpad move down and this
// causes a wl_pointer.axis vertical_scroll down event, the physical
// direction is 'identical'
// - if a user's fingers on a touchpad move down and this causes a
// wl_pointer.axis vertical_scroll up scroll up event ('natural
// scrolling'), the physical direction is 'inverted'.
//
// A client may use this information to adjust scroll motion of
// components. Specifically, enabling natural scrolling causes the
// content to change direction compared to traditional scrolling.
// Some widgets like volume control sliders should usually match the
// physical direction regardless of whether natural scrolling is
// active. This event enables clients to match the scroll direction of
// a widget to the physical direction.
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value.
// The protocol guarantees that each axis_relative_direction event is
// always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_relative_direction
// and its coupled axis event.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_relative_direction,
// wl_pointer.axis_discrete and wl_pointer.axis_source is not
// guaranteed.
type WlPointerAxisRelativeDirectionEvent struct {
	axis      WlPointerAxis
	direction WlPointerAxisRelativeDirection
	proxy     wayland.Proxy
}

// Axis axis type
func (e *WlPointerAxisRelativeDirectionEvent) Axis() WlPointerAxis {
	return e.axis
}

// Direction physical direction relative to axis motion
func (e *WlPointerAxisRelativeDirectionEvent) Direction() WlPointerAxisRelativeDirection {
	return e.direction
}

func (e *WlPointerAxisRelativeDirectionEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlPointer) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlPointerEnterEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		surface := r.ReadObject()
		if surface != nil {
			e.surface = surface.(*WlSurface)
		}
		e.surfaceX = r.ReadFixed()
		e.surfaceY = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlPointerLeaveEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		surface := r.ReadObject()
		if surface != nil {
			e.surface = surface.(*WlSurface)
		}
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlPointerMotionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.time = r.ReadUint()
		e.surfaceX = r.ReadFixed()
		e.surfaceY = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlPointerButtonEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		e.time = r.ReadUint()
		e.button = r.ReadUint()
		e.state = WlPointerButtonState(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	case 4:
		if i.Handler == nil {
			return
		}
		e := &WlPointerAxisEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.time = r.ReadUint()
		e.axis = WlPointerAxis(r.ReadUint())
		e.value = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 5:
		if i.Handler == nil {
			return
		}
		e := &WlPointerFrameEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 6:
		if i.Handler == nil {
			return
		}
		e := &WlPointerAxisSourceEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.axisSource = WlPointerAxisSource(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	case 7:
		if i.Handler == nil {
			return
		}
		e := &WlPointerAxisStopEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.time = r.ReadUint()
		e.axis = WlPointerAxis(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	case 8:
		if i.Handler == nil {
			return
		}
		e := &WlPointerAxisDiscreteEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.axis = WlPointerAxis(r.ReadUint())
		e.discrete = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 9:
		if i.Handler == nil {
			return
		}
		e := &WlPointerAxisValue120Event{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.axis = WlPointerAxis(r.ReadUint())
		e.value120 = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 10:
		if i.Handler == nil {
			return
		}
		e := &WlPointerAxisRelativeDirectionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.axis = WlPointerAxis(r.ReadUint())
		e.direction = WlPointerAxisRelativeDirection(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlKeyboard : keyboard input device
//
// The wl_keyboard interface represents one or more keyboards
// associated with a seat.
//
// Each wl_keyboard has the following logical state:
//
// - an active surface (possibly null),
// - the keys currently logically down,
// - the active modifiers,
// - the active group.
//
// By default, the active surface is null, the keys currently logically down
// are empty, the active modifiers and the active group are 0.
type WlKeyboard struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlKeyboardHandlers struct {
	OnKeymap     wayland.EventHandler
	OnEnter      wayland.EventHandler
	OnLeave      wayland.EventHandler
	OnKey        wayland.EventHandler
	OnModifiers  wayland.EventHandler
	OnRepeatInfo wayland.EventHandler
	Unhandled    wayland.EventHandler
}

func (h WlKeyboardHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlKeyboardKeymapEvent:
		if h.OnKeymap != nil && h.OnKeymap.Handle(e) {
			return true
		}
	case *WlKeyboardEnterEvent:
		if h.OnEnter != nil && h.OnEnter.Handle(e) {
			return true
		}
	case *WlKeyboardLeaveEvent:
		if h.OnLeave != nil && h.OnLeave.Handle(e) {
			return true
		}
	case *WlKeyboardKeyEvent:
		if h.OnKey != nil && h.OnKey.Handle(e) {
			return true
		}
	case *WlKeyboardModifiersEvent:
		if h.OnModifiers != nil && h.OnModifiers.Handle(e) {
			return true
		}
	case *WlKeyboardRepeatInfoEvent:
		if h.OnRepeatInfo != nil && h.OnRepeatInfo.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlKeyboard : keyboard input device
//
// The wl_keyboard interface represents one or more keyboards
// associated with a seat.
//
// Each wl_keyboard has the following logical state:
//
// - an active surface (possibly null),
// - the keys currently logically down,
// - the active modifiers,
// - the active group.
//
// By default, the active surface is null, the keys currently logically down
// are empty, the active modifiers and the active group are 0.
func NewWlKeyboard(handler wayland.EventHandler) *WlKeyboard {
	return &WlKeyboard{Handler: handler}
}
func (i *WlKeyboard) Name() string {
	return "wl_keyboard"
}

// Release : release the keyboard object
func (i *WlKeyboard) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlKeyboard) Destroy() {
	i.Release()
}

// WlKeyboardKeymapFormat : keyboard mapping format
//
// This specifies the format of the keymap provided to the
// client with the wl_keyboard.keymap event.
type WlKeyboardKeymapFormat uint32

const (
	// WlKeyboardKeymapFormatNoKeymap : no keymap; client must understand how to interpret the raw keycode
	WlKeyboardKeymapFormatNoKeymap WlKeyboardKeymapFormat = 0
	// WlKeyboardKeymapFormatXkbV1 : libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
	WlKeyboardKeymapFormatXkbV1 WlKeyboardKeymapFormat = 1
)

func (e WlKeyboardKeymapFormat) Name() string {
	switch e {
	case WlKeyboardKeymapFormatNoKeymap:
		return "no_keymap"
	case WlKeyboardKeymapFormatXkbV1:
		return "xkb_v1"
	default:
		return ""
	}
}
func (e WlKeyboardKeymapFormat) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("keymap_format(%d)", e)
	}
	return fmt.Sprintf("keymap_format(%s)", name)
}

// WlKeyboardKeyState : physical key state
//
// Describes the physical state of a key that produced the key event.
//
// Since version 10, the key can be in a "repeated" pseudo-state which
// means the same as "pressed", but is used to signal repetition in the
// key event.
//
// The key may only enter the repeated state after entering the pressed
// state and before entering the released state. This event may be
// generated multiple times while the key is down.
type WlKeyboardKeyState uint32

const (
	// WlKeyboardKeyStateReleased : key is not pressed
	WlKeyboardKeyStateReleased WlKeyboardKeyState = 0
	// WlKeyboardKeyStatePressed : key is pressed
	WlKeyboardKeyStatePressed WlKeyboardKeyState = 1
	// WlKeyboardKeyStateRepeated : key was repeated
	WlKeyboardKeyStateRepeated WlKeyboardKeyState = 2
)

func (e WlKeyboardKeyState) Name() string {
	switch e {
	case WlKeyboardKeyStateReleased:
		return "released"
	case WlKeyboardKeyStatePressed:
		return "pressed"
	case WlKeyboardKeyStateRepeated:
		return "repeated"
	default:
		return ""
	}
}
func (e WlKeyboardKeyState) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("key_state(%d)", e)
	}
	return fmt.Sprintf("key_state(%s)", name)
}

// WlKeyboardKeymapEvent : keyboard mapping
//
// This event provides a file descriptor to the client which can be
// memory-mapped in read-only mode to provide a keyboard mapping
// description.
//
// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
// the recipient, as MAP_SHARED may fail.
type WlKeyboardKeymapEvent struct {
	format WlKeyboardKeymapFormat
	fd     int
	size   uint32
	proxy  wayland.Proxy
}

// Format keymap format
func (e *WlKeyboardKeymapEvent) Format() WlKeyboardKeymapFormat {
	return e.format
}

// Fd keymap file descriptor
func (e *WlKeyboardKeymapEvent) Fd() int {
	return e.fd
}

// Size keymap size, in bytes
func (e *WlKeyboardKeymapEvent) Size() uint32 {
	return e.size
}

func (e *WlKeyboardKeymapEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlKeyboardEnterEvent : enter event
//
// Notification that this seat's keyboard focus is on a certain
// surface.
//
// The compositor must send the wl_keyboard.modifiers event after this
// event.
//
// In the wl_keyboard logical state, this event sets the active surface to
// the surface argument and the keys currently logically down to the keys
// in the keys argument. The compositor must not send this event if the
// wl_keyboard already had an active surface immediately before this event.
//
// Clients should not use the list of pressed keys to emulate key-press
// events. The order of keys in the list is unspecified.
type WlKeyboardEnterEvent struct {
	serial  uint32
	surface *WlSurface
	keys    []byte
	proxy   wayland.Proxy
}

// Serial serial number of the enter event
func (e *WlKeyboardEnterEvent) Serial() uint32 {
	return e.serial
}

// Surface surface gaining keyboard focus
func (e *WlKeyboardEnterEvent) Surface() *WlSurface {
	return e.surface
}

// Keys the keys currently logically down
func (e *WlKeyboardEnterEvent) Keys() []byte {
	return e.keys
}

func (e *WlKeyboardEnterEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlKeyboardLeaveEvent : leave event
//
// Notification that this seat's keyboard focus is no longer on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
// In the wl_keyboard logical state, this event resets all values to their
// defaults. The compositor must not send this event if the active surface
// of the wl_keyboard was not equal to the surface argument immediately
// before this event.
type WlKeyboardLeaveEvent struct {
	serial  uint32
	surface *WlSurface
	proxy   wayland.Proxy
}

// Serial serial number of the leave event
func (e *WlKeyboardLeaveEvent) Serial() uint32 {
	return e.serial
}

// Surface surface that lost keyboard focus
func (e *WlKeyboardLeaveEvent) Surface() *WlSurface {
	return e.surface
}

func (e *WlKeyboardLeaveEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlKeyboardKeyEvent : key event
//
// A key was pressed or released.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The key is a platform-specific key code that can be interpreted
// by feeding it to the keyboard mapping (see the keymap event).
//
// If this event produces a change in modifiers, then the resulting
// wl_keyboard.modifiers event must be sent after this event.
//
// In the wl_keyboard logical state, this event adds the key to the keys
// currently logically down (if the state argument is pressed) or removes
// the key from the keys currently logically down (if the state argument is
// released). The compositor must not send this event if the wl_keyboard
// did not have an active surface immediately before this event. The
// compositor must not send this event if state is pressed (resp. released)
// and the key was already logically down (resp. was not logically down)
// immediately before this event.
//
// Since version 10, compositors may send key events with the "repeated"
// key state when a wl_keyboard.repeat_info event with a rate argument of
// 0 has been received. This allows the compositor to take over the
// responsibility of key repetition.
type WlKeyboardKeyEvent struct {
	serial uint32
	time   uint32
	key    uint32
	state  WlKeyboardKeyState
	proxy  wayland.Proxy
}

// Serial serial number of the key event
func (e *WlKeyboardKeyEvent) Serial() uint32 {
	return e.serial
}

// Time timestamp with millisecond granularity
func (e *WlKeyboardKeyEvent) Time() uint32 {
	return e.time
}

// Key key that produced the event
func (e *WlKeyboardKeyEvent) Key() uint32 {
	return e.key
}

// State physical state of the key
func (e *WlKeyboardKeyEvent) State() WlKeyboardKeyState {
	return e.state
}

func (e *WlKeyboardKeyEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlKeyboardModifiersEvent : modifier and group state
//
// Notifies clients that the modifier and/or group state has
// changed, and it should update its local state.
//
// The compositor may send this event without a surface of the client
// having keyboard focus, for example to tie modifier information to
// pointer focus instead. If a modifier event with pressed modifiers is sent
// without a prior enter event, the client can assume the modifier state is
// valid until it receives the next wl_keyboard.modifiers event. In order to
// reset the modifier state again, the compositor can send a
// wl_keyboard.modifiers event with no pressed modifiers.
//
// In the wl_keyboard logical state, this event updates the modifiers and
// group.
type WlKeyboardModifiersEvent struct {
	serial        uint32
	modsDepressed uint32
	modsLatched   uint32
	modsLocked    uint32
	group         uint32
	proxy         wayland.Proxy
}

// Serial serial number of the modifiers event
func (e *WlKeyboardModifiersEvent) Serial() uint32 {
	return e.serial
}

// ModsDepressed depressed modifiers
func (e *WlKeyboardModifiersEvent) ModsDepressed() uint32 {
	return e.modsDepressed
}

// ModsLatched latched modifiers
func (e *WlKeyboardModifiersEvent) ModsLatched() uint32 {
	return e.modsLatched
}

// ModsLocked locked modifiers
func (e *WlKeyboardModifiersEvent) ModsLocked() uint32 {
	return e.modsLocked
}

// Group keyboard layout
func (e *WlKeyboardModifiersEvent) Group() uint32 {
	return e.group
}

func (e *WlKeyboardModifiersEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlKeyboardRepeatInfoEvent : repeat rate and delay
//
// Informs the client about the keyboard's repeat rate and delay.
//
// This event is sent as soon as the wl_keyboard object has been created,
// and is guaranteed to be received by the client before any key press
// event.
//
// Negative values for either rate or delay are illegal. A rate of zero
// will disable any repeating (regardless of the value of delay).
//
// This event can be sent later on as well with a new value if necessary,
// so clients should continue listening for the event past the creation
// of wl_keyboard.
type WlKeyboardRepeatInfoEvent struct {
	rate  int32
	delay int32
	proxy wayland.Proxy
}

// Rate the rate of repeating keys in characters per second
func (e *WlKeyboardRepeatInfoEvent) Rate() int32 {
	return e.rate
}

// Delay delay in milliseconds since key down until repeating starts
func (e *WlKeyboardRepeatInfoEvent) Delay() int32 {
	return e.delay
}

func (e *WlKeyboardRepeatInfoEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlKeyboard) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			for _, fd := range msg.FDs {
				syscall.Close(fd)
			}
			return
		}
		e := &WlKeyboardKeymapEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.format = WlKeyboardKeymapFormat(r.ReadUint())
		e.fd = r.ReadFd()
		e.size = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
		for _, fd := range msg.FDs {
			syscall.Close(fd)
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlKeyboardEnterEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		surface := r.ReadObject()
		if surface != nil {
			e.surface = surface.(*WlSurface)
		}
		e.keys = r.ReadArray()
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlKeyboardLeaveEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		surface := r.ReadObject()
		if surface != nil {
			e.surface = surface.(*WlSurface)
		}
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlKeyboardKeyEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		e.time = r.ReadUint()
		e.key = r.ReadUint()
		e.state = WlKeyboardKeyState(r.ReadUint())
		if i.Handler.Handle(e) {
			return
		}
	case 4:
		if i.Handler == nil {
			return
		}
		e := &WlKeyboardModifiersEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		e.modsDepressed = r.ReadUint()
		e.modsLatched = r.ReadUint()
		e.modsLocked = r.ReadUint()
		e.group = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	case 5:
		if i.Handler == nil {
			return
		}
		e := &WlKeyboardRepeatInfoEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.rate = r.ReadInt()
		e.delay = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlTouch : touchscreen input device
//
// The wl_touch interface represents a touchscreen
// associated with a seat.
//
// Touch interactions can consist of one or more contacts.
// For each contact, a series of events is generated, starting
// with a down event, followed by zero or more motion events,
// and ending with an up event. Events relating to the same
// contact point can be identified by the ID of the sequence.
type WlTouch struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlTouchHandlers struct {
	OnDown        wayland.EventHandler
	OnUp          wayland.EventHandler
	OnMotion      wayland.EventHandler
	OnFrame       wayland.EventHandler
	OnCancel      wayland.EventHandler
	OnShape       wayland.EventHandler
	OnOrientation wayland.EventHandler
	Unhandled     wayland.EventHandler
}

func (h WlTouchHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlTouchDownEvent:
		if h.OnDown != nil && h.OnDown.Handle(e) {
			return true
		}
	case *WlTouchUpEvent:
		if h.OnUp != nil && h.OnUp.Handle(e) {
			return true
		}
	case *WlTouchMotionEvent:
		if h.OnMotion != nil && h.OnMotion.Handle(e) {
			return true
		}
	case *WlTouchFrameEvent:
		if h.OnFrame != nil && h.OnFrame.Handle(e) {
			return true
		}
	case *WlTouchCancelEvent:
		if h.OnCancel != nil && h.OnCancel.Handle(e) {
			return true
		}
	case *WlTouchShapeEvent:
		if h.OnShape != nil && h.OnShape.Handle(e) {
			return true
		}
	case *WlTouchOrientationEvent:
		if h.OnOrientation != nil && h.OnOrientation.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlTouch : touchscreen input device
//
// The wl_touch interface represents a touchscreen
// associated with a seat.
//
// Touch interactions can consist of one or more contacts.
// For each contact, a series of events is generated, starting
// with a down event, followed by zero or more motion events,
// and ending with an up event. Events relating to the same
// contact point can be identified by the ID of the sequence.
func NewWlTouch(handler wayland.EventHandler) *WlTouch {
	return &WlTouch{Handler: handler}
}
func (i *WlTouch) Name() string {
	return "wl_touch"
}

// Release : release the touch object
func (i *WlTouch) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlTouch) Destroy() {
	i.Release()
}

// WlTouchDownEvent : touch down event and beginning of a touch sequence
//
// A new touch point has appeared on the surface. This touch point is
// assigned a unique ID. Future events from this touch point reference
// this ID. The ID ceases to be valid after a touch up event and may be
// reused in the future.
type WlTouchDownEvent struct {
	serial  uint32
	time    uint32
	surface *WlSurface
	id      int32
	x       float64
	y       float64
	proxy   wayland.Proxy
}

// Serial serial number of the touch down event
func (e *WlTouchDownEvent) Serial() uint32 {
	return e.serial
}

// Time timestamp with millisecond granularity
func (e *WlTouchDownEvent) Time() uint32 {
	return e.time
}

// Surface surface touched
func (e *WlTouchDownEvent) Surface() *WlSurface {
	return e.surface
}

// ID the unique ID of this touch point
func (e *WlTouchDownEvent) ID() int32 {
	return e.id
}

// X surface-local x coordinate
func (e *WlTouchDownEvent) X() float64 {
	return e.x
}

// Y surface-local y coordinate
func (e *WlTouchDownEvent) Y() float64 {
	return e.y
}

func (e *WlTouchDownEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlTouchUpEvent : end of a touch event sequence
//
// The touch point has disappeared. No further events will be sent for
// this touch point and the touch point's ID is released and may be
// reused in a future touch down event.
type WlTouchUpEvent struct {
	serial uint32
	time   uint32
	id     int32
	proxy  wayland.Proxy
}

// Serial serial number of the touch up event
func (e *WlTouchUpEvent) Serial() uint32 {
	return e.serial
}

// Time timestamp with millisecond granularity
func (e *WlTouchUpEvent) Time() uint32 {
	return e.time
}

// ID the unique ID of this touch point
func (e *WlTouchUpEvent) ID() int32 {
	return e.id
}

func (e *WlTouchUpEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlTouchMotionEvent : update of touch point coordinates
//
// A touch point has changed coordinates.
type WlTouchMotionEvent struct {
	time  uint32
	id    int32
	x     float64
	y     float64
	proxy wayland.Proxy
}

// Time timestamp with millisecond granularity
func (e *WlTouchMotionEvent) Time() uint32 {
	return e.time
}

// ID the unique ID of this touch point
func (e *WlTouchMotionEvent) ID() int32 {
	return e.id
}

// X surface-local x coordinate
func (e *WlTouchMotionEvent) X() float64 {
	return e.x
}

// Y surface-local y coordinate
func (e *WlTouchMotionEvent) Y() float64 {
	return e.y
}

func (e *WlTouchMotionEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlTouchFrameEvent : end of touch frame event
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// A wl_touch.frame terminates at least one event but otherwise no
// guarantee is provided about the set of events within a frame. A client
// must assume that any state not updated in a frame is unchanged from the
// previously known state.
type WlTouchFrameEvent struct {
	proxy wayland.Proxy
}

func (e *WlTouchFrameEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlTouchCancelEvent : touch session cancelled
//
// Sent if the compositor decides the touch stream is a global
// gesture. No further events are sent to the clients from that
// particular gesture. Touch cancellation applies to all touch points
// currently active on this client's surface. The client is
// responsible for finalizing the touch points, future touch points on
// this surface may reuse the touch point ID.
//
// No frame event is required after the cancel event.
type WlTouchCancelEvent struct {
	proxy wayland.Proxy
}

func (e *WlTouchCancelEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlTouchShapeEvent : update shape of touch point
//
// Sent when a touchpoint has changed its shape.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.orientation may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.shape event for this touch ID but both events may occur within
// the same wl_touch.frame.
//
// A touchpoint shape is approximated by an ellipse through the major and
// minor axis length. The major axis length describes the longer diameter
// of the ellipse, while the minor axis length describes the shorter
// diameter. Major and minor are orthogonal and both are specified in
// surface-local coordinates. The center of the ellipse is always at the
// touchpoint location as reported by wl_touch.down or wl_touch.move.
//
// This event is only sent by the compositor if the touch device supports
// shape reports. The client has to make reasonable assumptions about the
// shape if it did not receive this event.
type WlTouchShapeEvent struct {
	id    int32
	major float64
	minor float64
	proxy wayland.Proxy
}

// ID the unique ID of this touch point
func (e *WlTouchShapeEvent) ID() int32 {
	return e.id
}

// Major length of the major axis in surface-local coordinates
func (e *WlTouchShapeEvent) Major() float64 {
	return e.major
}

// Minor length of the minor axis in surface-local coordinates
func (e *WlTouchShapeEvent) Minor() float64 {
	return e.minor
}

func (e *WlTouchShapeEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlTouchOrientationEvent : update orientation of touch point
//
// Sent when a touchpoint has changed its orientation.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.shape may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.orientation event for this touch ID but both events may occur
// within the same wl_touch.frame.
//
// The orientation describes the clockwise angle of a touchpoint's major
// axis to the positive surface y-axis and is normalized to the -180 to
// +180 degree range. The granularity of orientation depends on the touch
// device, some devices only support binary rotation values between 0 and
// 90 degrees.
//
// This event is only sent by the compositor if the touch device supports
// orientation reports.
type WlTouchOrientationEvent struct {
	id          int32
	orientation float64
	proxy       wayland.Proxy
}

// ID the unique ID of this touch point
func (e *WlTouchOrientationEvent) ID() int32 {
	return e.id
}

// Orientation angle between major axis and positive surface y-axis in degrees
func (e *WlTouchOrientationEvent) Orientation() float64 {
	return e.orientation
}

func (e *WlTouchOrientationEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlTouch) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlTouchDownEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		e.time = r.ReadUint()
		surface := r.ReadObject()
		if surface != nil {
			e.surface = surface.(*WlSurface)
		}
		e.id = r.ReadInt()
		e.x = r.ReadFixed()
		e.y = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlTouchUpEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.serial = r.ReadUint()
		e.time = r.ReadUint()
		e.id = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlTouchMotionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.time = r.ReadUint()
		e.id = r.ReadInt()
		e.x = r.ReadFixed()
		e.y = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlTouchFrameEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 4:
		if i.Handler == nil {
			return
		}
		e := &WlTouchCancelEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 5:
		if i.Handler == nil {
			return
		}
		e := &WlTouchShapeEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.id = r.ReadInt()
		e.major = r.ReadFixed()
		e.minor = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	case 6:
		if i.Handler == nil {
			return
		}
		e := &WlTouchOrientationEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.id = r.ReadInt()
		e.orientation = r.ReadFixed()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlOutput : compositor output region
//
// An output describes part of the compositor geometry.  The
// compositor works in the 'compositor coordinate system' and an
// output corresponds to a rectangular area in that space that is
// actually visible.  This typically corresponds to a monitor that
// displays part of the compositor space.  This object is published
// as global during start up, or when a monitor is hotplugged.
type WlOutput struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type WlOutputHandlers struct {
	OnGeometry    wayland.EventHandler
	OnMode        wayland.EventHandler
	OnDone        wayland.EventHandler
	OnScale       wayland.EventHandler
	OnName        wayland.EventHandler
	OnDescription wayland.EventHandler
	Unhandled     wayland.EventHandler
}

func (h WlOutputHandlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *WlOutputGeometryEvent:
		if h.OnGeometry != nil && h.OnGeometry.Handle(e) {
			return true
		}
	case *WlOutputModeEvent:
		if h.OnMode != nil && h.OnMode.Handle(e) {
			return true
		}
	case *WlOutputDoneEvent:
		if h.OnDone != nil && h.OnDone.Handle(e) {
			return true
		}
	case *WlOutputScaleEvent:
		if h.OnScale != nil && h.OnScale.Handle(e) {
			return true
		}
	case *WlOutputNameEvent:
		if h.OnName != nil && h.OnName.Handle(e) {
			return true
		}
	case *WlOutputDescriptionEvent:
		if h.OnDescription != nil && h.OnDescription.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewWlOutput : compositor output region
//
// An output describes part of the compositor geometry.  The
// compositor works in the 'compositor coordinate system' and an
// output corresponds to a rectangular area in that space that is
// actually visible.  This typically corresponds to a monitor that
// displays part of the compositor space.  This object is published
// as global during start up, or when a monitor is hotplugged.
func NewWlOutput(handler wayland.EventHandler) *WlOutput {
	return &WlOutput{Handler: handler}
}
func (i *WlOutput) Name() string {
	return "wl_output"
}

// Release : release the output object
//
// Using this request a client can tell the server that it is not going to
// use the output object anymore.
func (i *WlOutput) Release() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func (i *WlOutput) Destroy() {
	i.Release()
}

// WlOutputSubpixel : subpixel geometry information
//
// This enumeration describes how the physical
// pixels on an output are laid out.
type WlOutputSubpixel uint32

const (
	// WlOutputSubpixelUnknown : unknown geometry
	WlOutputSubpixelUnknown WlOutputSubpixel = 0
	// WlOutputSubpixelNone : no geometry
	WlOutputSubpixelNone WlOutputSubpixel = 1
	// WlOutputSubpixelHorizontalRgb : horizontal RGB
	WlOutputSubpixelHorizontalRgb WlOutputSubpixel = 2
	// WlOutputSubpixelHorizontalBgr : horizontal BGR
	WlOutputSubpixelHorizontalBgr WlOutputSubpixel = 3
	// WlOutputSubpixelVerticalRgb : vertical RGB
	WlOutputSubpixelVerticalRgb WlOutputSubpixel = 4
	// WlOutputSubpixelVerticalBgr : vertical BGR
	WlOutputSubpixelVerticalBgr WlOutputSubpixel = 5
)

func (e WlOutputSubpixel) Name() string {
	switch e {
	case WlOutputSubpixelUnknown:
		return "unknown"
	case WlOutputSubpixelNone:
		return "none"
	case WlOutputSubpixelHorizontalRgb:
		return "horizontal_rgb"
	case WlOutputSubpixelHorizontalBgr:
		return "horizontal_bgr"
	case WlOutputSubpixelVerticalRgb:
		return "vertical_rgb"
	case WlOutputSubpixelVerticalBgr:
		return "vertical_bgr"
	default:
		return ""
	}
}
func (e WlOutputSubpixel) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("subpixel(%d)", e)
	}
	return fmt.Sprintf("subpixel(%s)", name)
}

// WlOutputTransform : transformation applied to buffer contents
//
// This describes transformations that clients and compositors apply to
// buffer contents.
//
// The flipped values correspond to an initial flip around a
// vertical axis followed by rotation.
//
// The purpose is mainly to allow clients to render accordingly and
// tell the compositor, so that for fullscreen surfaces, the
// compositor will still be able to scan out directly from client
// surfaces.
type WlOutputTransform uint32

const (
	// WlOutputTransformNormal : no transform
	WlOutputTransformNormal WlOutputTransform = 0
	// WlOutputTransform90 : 90 degrees counter-clockwise
	WlOutputTransform90 WlOutputTransform = 1
	// WlOutputTransform180 : 180 degrees counter-clockwise
	WlOutputTransform180 WlOutputTransform = 2
	// WlOutputTransform270 : 270 degrees counter-clockwise
	WlOutputTransform270 WlOutputTransform = 3
	// WlOutputTransformFlipped : 180 degree flip around a vertical axis
	WlOutputTransformFlipped WlOutputTransform = 4
	// WlOutputTransformFlipped90 : flip and rotate 90 degrees counter-clockwise
	WlOutputTransformFlipped90 WlOutputTransform = 5
	// WlOutputTransformFlipped180 : flip and rotate 180 degrees counter-clockwise
	WlOutputTransformFlipped180 WlOutputTransform = 6
	// WlOutputTransformFlipped270 : flip and rotate 270 degrees counter-clockwise
	WlOutputTransformFlipped270 WlOutputTransform = 7
)

func (e WlOutputTransform) Name() string {
	switch e {
	case WlOutputTransformNormal:
		return "normal"
	case WlOutputTransform90:
		return "90"
	case WlOutputTransform180:
		return "180"
	case WlOutputTransform270:
		return "270"
	case WlOutputTransformFlipped:
		return "flipped"
	case WlOutputTransformFlipped90:
		return "flipped_90"
	case WlOutputTransformFlipped180:
		return "flipped_180"
	case WlOutputTransformFlipped270:
		return "flipped_270"
	default:
		return ""
	}
}
func (e WlOutputTransform) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("transform(%d)", e)
	}
	return fmt.Sprintf("transform(%s)", name)
}

// WlOutputMode : mode information
//
// These flags describe properties of an output mode.
// They are used in the flags bitfield of the mode event.
type WlOutputMode uint32

const (
	// WlOutputModeCurrent : indicates this is the current mode
	WlOutputModeCurrent WlOutputMode = 0x1
	// WlOutputModePreferred : indicates this is the preferred mode
	WlOutputModePreferred WlOutputMode = 0x2
)

func (e WlOutputMode) Name() string {
	switch e {
	case WlOutputModeCurrent:
		return "current"
	case WlOutputModePreferred:
		return "preferred"
	default:
		return ""
	}
}
func (e WlOutputMode) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("mode(%d)", e)
	}
	return fmt.Sprintf("mode(%s)", name)
}

// WlOutputGeometryEvent : properties of the output
//
// The geometry event describes geometric properties of the output.
// The event is sent when binding to the output object and whenever
// any of the properties change.
//
// The physical size can be set to zero if it doesn't make sense for this
// output (e.g. for projectors or virtual outputs).
//
// The geometry event will be followed by a done event (starting from
// version 2).
//
// Clients should use wl_surface.preferred_buffer_transform instead of the
// transform advertised by this event to find the preferred buffer
// transform to use for a surface.
//
// Note: wl_output only advertises partial information about the output
// position and identification. Some compositors, for instance those not
// implementing a desktop-style output layout or those exposing virtual
// outputs, might fake this information. Instead of using x and y, clients
// should use xdg_output.logical_position. Instead of using make and model,
// clients should use name and description.
type WlOutputGeometryEvent struct {
	x              int32
	y              int32
	physicalWidth  int32
	physicalHeight int32
	subpixel       int32
	make           string
	model          string
	transform      int32
	proxy          wayland.Proxy
}

// X x position within the global compositor space
func (e *WlOutputGeometryEvent) X() int32 {
	return e.x
}

// Y y position within the global compositor space
func (e *WlOutputGeometryEvent) Y() int32 {
	return e.y
}

// PhysicalWidth width in millimeters of the output
func (e *WlOutputGeometryEvent) PhysicalWidth() int32 {
	return e.physicalWidth
}

// PhysicalHeight height in millimeters of the output
func (e *WlOutputGeometryEvent) PhysicalHeight() int32 {
	return e.physicalHeight
}

// Subpixel subpixel orientation of the output
func (e *WlOutputGeometryEvent) Subpixel() int32 {
	return e.subpixel
}

// Make textual description of the manufacturer
func (e *WlOutputGeometryEvent) Make() string {
	return e.make
}

// Model textual description of the model
func (e *WlOutputGeometryEvent) Model() string {
	return e.model
}

// Transform additional transformation applied to buffer contents during presentation
func (e *WlOutputGeometryEvent) Transform() int32 {
	return e.transform
}

func (e *WlOutputGeometryEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlOutputModeEvent : advertise available modes for the output
//
// The mode event describes an available mode for the output.
//
// The event is sent when binding to the output object and there
// will always be one mode, the current mode.  The event is sent
// again if an output changes mode, for the mode that is now
// current.  In other words, the current mode is always the last
// mode that was received with the current flag set.
//
// Non-current modes are deprecated. A compositor can decide to only
// advertise the current mode and never send other modes. Clients
// should not rely on non-current modes.
//
// The size of a mode is given in physical hardware units of
// the output device. This is not necessarily the same as
// the output size in the global compositor space. For instance,
// the output may be scaled, as described in wl_output.scale,
// or transformed, as described in wl_output.transform. Clients
// willing to retrieve the output size in the global compositor
// space should use xdg_output.logical_size instead.
//
// The vertical refresh rate can be set to zero if it doesn't make
// sense for this output (e.g. for virtual outputs).
//
// The mode event will be followed by a done event (starting from
// version 2).
//
// Clients should not use the refresh rate to schedule frames. Instead,
// they should use the wl_surface.frame event or the presentation-time
// protocol.
//
// Note: this information is not always meaningful for all outputs. Some
// compositors, such as those exposing virtual outputs, might fake the
// refresh rate or the size.
type WlOutputModeEvent struct {
	flags   WlOutputMode
	width   int32
	height  int32
	refresh int32
	proxy   wayland.Proxy
}

// Flags bitfield of mode flags
func (e *WlOutputModeEvent) Flags() WlOutputMode {
	return e.flags
}

// Width width of the mode in hardware units
func (e *WlOutputModeEvent) Width() int32 {
	return e.width
}

// Height height of the mode in hardware units
func (e *WlOutputModeEvent) Height() int32 {
	return e.height
}

// Refresh vertical refresh rate in mHz
func (e *WlOutputModeEvent) Refresh() int32 {
	return e.refresh
}

func (e *WlOutputModeEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlOutputDoneEvent : sent all information about output
//
// This event is sent after all other properties have been
// sent after binding to the output object and after any
// other property changes done after that. This allows
// changes to the output properties to be seen as
// atomic, even if they happen via multiple events.
type WlOutputDoneEvent struct {
	proxy wayland.Proxy
}

func (e *WlOutputDoneEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlOutputScaleEvent : output scaling properties
//
// This event contains scaling geometry information
// that is not in the geometry event. It may be sent after
// binding the output object or if the output scale changes
// later. The compositor will emit a non-zero, positive
// value for scale. If it is not sent, the client should
// assume a scale of 1.
//
// A scale larger than 1 means that the compositor will
// automatically scale surface buffers by this amount
// when rendering. This is used for very high resolution
// displays where applications rendering at the native
// resolution would be too small to be legible.
//
// Clients should use wl_surface.preferred_buffer_scale
// instead of this event to find the preferred buffer
// scale to use for a surface.
//
// The scale event will be followed by a done event.
type WlOutputScaleEvent struct {
	factor int32
	proxy  wayland.Proxy
}

// Factor scaling factor of output
func (e *WlOutputScaleEvent) Factor() int32 {
	return e.factor
}

func (e *WlOutputScaleEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlOutputNameEvent : name of this output
//
// Many compositors will assign user-friendly names to their outputs, show
// them to the user, allow the user to refer to an output, etc. The client
// may wish to know this name as well to offer the user similar behaviors.
//
// The name is a UTF-8 string with no convention defined for its contents.
// Each name is unique among all wl_output globals. The name is only
// guaranteed to be unique for the compositor instance.
//
// The same output name is used for all clients for a given wl_output
// global. Thus, the name can be shared across processes to refer to a
// specific wl_output global.
//
// The name is not guaranteed to be persistent across sessions, thus cannot
// be used to reliably identify an output in e.g. configuration files.
//
// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
// not assume that the name is a reflection of an underlying DRM connector,
// X11 connection, etc.
//
// The name event is sent after binding the output object. This event is
// only sent once per output object, and the name does not change over the
// lifetime of the wl_output global.
//
// Compositors may re-use the same output name if the wl_output global is
// destroyed and re-created later. Compositors should avoid re-using the
// same name if possible.
//
// The name event will be followed by a done event.
type WlOutputNameEvent struct {
	name  string
	proxy wayland.Proxy
}

// Name output name
func (e *WlOutputNameEvent) Name() string {
	return e.name
}

func (e *WlOutputNameEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// WlOutputDescriptionEvent : human-readable description of this output
//
// Many compositors can produce human-readable descriptions of their
// outputs. The client may wish to know this description as well, e.g. for
// output selection purposes.
//
// The description is a UTF-8 string with no convention defined for its
// contents. The description is not guaranteed to be unique among all
// wl_output globals. Examples might include 'Foocorp 11" Display' or
// 'Virtual X11 output via :1'.
//
// The description event is sent after binding the output object and
// whenever the description changes. The description is optional, and may
// not be sent at all.
//
// The description event will be followed by a done event.
type WlOutputDescriptionEvent struct {
	description string
	proxy       wayland.Proxy
}

// Description output description
func (e *WlOutputDescriptionEvent) Description() string {
	return e.description
}

func (e *WlOutputDescriptionEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *WlOutput) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &WlOutputGeometryEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.x = r.ReadInt()
		e.y = r.ReadInt()
		e.physicalWidth = r.ReadInt()
		e.physicalHeight = r.ReadInt()
		e.subpixel = r.ReadInt()
		e.make = r.ReadString()
		e.model = r.ReadString()
		e.transform = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &WlOutputModeEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.flags = WlOutputMode(r.ReadUint())
		e.width = r.ReadInt()
		e.height = r.ReadInt()
		e.refresh = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 2:
		if i.Handler == nil {
			return
		}
		e := &WlOutputDoneEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	case 3:
		if i.Handler == nil {
			return
		}
		e := &WlOutputScaleEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.factor = r.ReadInt()
		if i.Handler.Handle(e) {
			return
		}
	case 4:
		if i.Handler == nil {
			return
		}
		e := &WlOutputNameEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.name = r.ReadString()
		if i.Handler.Handle(e) {
			return
		}
	case 5:
		if i.Handler == nil {
			return
		}
		e := &WlOutputDescriptionEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.description = r.ReadString()
		if i.Handler.Handle(e) {
			return
		}
	}
}

// WlRegion : region interface
//
// A region object describes an area.
//
// Region objects are used to describe the opaque and input
// regions of a surface.
type WlRegion struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlRegion : region interface
//
// A region object describes an area.
//
// Region objects are used to describe the opaque and input
// regions of a surface.
func NewWlRegion() *WlRegion {
	return &WlRegion{}
}
func (i *WlRegion) Name() string {
	return "wl_region"
}

// Destroy : destroy region
//
// Destroy the region.  This will invalidate the object ID.
func (i *WlRegion) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Add : add rectangle to region
//
// Add the specified rectangle to the region.
//
// x : region-local x coordinate
// y : region-local y coordinate
// width : rectangle width
// height : rectangle height
func (i *WlRegion) Add(x int32, y int32, width int32, height int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	w.WriteInt(x)
	w.WriteInt(y)
	w.WriteInt(width)
	w.WriteInt(height)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Subtract : subtract rectangle from region
//
// Subtract the specified rectangle from the region.
//
// x : region-local x coordinate
// y : region-local y coordinate
// width : rectangle width
// height : rectangle height
func (i *WlRegion) Subtract(x int32, y int32, width int32, height int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	w.WriteInt(x)
	w.WriteInt(y)
	w.WriteInt(width)
	w.WriteInt(height)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlSubcompositor : sub-surface compositing
//
// The global interface exposing sub-surface compositing capabilities.
// A wl_surface, that has sub-surfaces associated, is called the
// parent surface. Sub-surfaces can be arbitrarily nested and create
// a tree of sub-surfaces.
//
// The root surface in a tree of sub-surfaces is the main
// surface. The main surface cannot be a sub-surface, because
// sub-surfaces must always have a parent.
//
// A main surface with its sub-surfaces forms a (compound) window.
// For window management purposes, this set of wl_surface objects is
// to be considered as a single window, and it should also behave as
// such.
//
// The aim of sub-surfaces is to offload some of the compositing work
// within a window from clients to the compositor. A prime example is
// a video player with decorations and video in separate wl_surface
// objects. This should allow the compositor to pass YUV video buffer
// processing to dedicated overlay hardware when possible.
type WlSubcompositor struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlSubcompositor : sub-surface compositing
//
// The global interface exposing sub-surface compositing capabilities.
// A wl_surface, that has sub-surfaces associated, is called the
// parent surface. Sub-surfaces can be arbitrarily nested and create
// a tree of sub-surfaces.
//
// The root surface in a tree of sub-surfaces is the main
// surface. The main surface cannot be a sub-surface, because
// sub-surfaces must always have a parent.
//
// A main surface with its sub-surfaces forms a (compound) window.
// For window management purposes, this set of wl_surface objects is
// to be considered as a single window, and it should also behave as
// such.
//
// The aim of sub-surfaces is to offload some of the compositing work
// within a window from clients to the compositor. A prime example is
// a video player with decorations and video in separate wl_surface
// objects. This should allow the compositor to pass YUV video buffer
// processing to dedicated overlay hardware when possible.
func NewWlSubcompositor() *WlSubcompositor {
	return &WlSubcompositor{}
}
func (i *WlSubcompositor) Name() string {
	return "wl_subcompositor"
}

// Destroy : unbind from the subcompositor interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other
// objects, wl_subsurface objects included.
func (i *WlSubcompositor) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// GetSubsurface : give a surface the role sub-surface
//
// Create a sub-surface interface for the given surface, and
// associate it with the given parent surface. This turns a
// plain wl_surface into a sub-surface.
//
// The to-be sub-surface must not already have another role, and it
// must not have an existing wl_subsurface object. Otherwise the
// bad_surface protocol error is raised.
//
// Adding sub-surfaces to a parent is a double-buffered operation on the
// parent (see wl_surface.commit). The effect of adding a sub-surface
// becomes visible on the next time the state of the parent surface is
// applied.
//
// The parent surface must not be one of the child surface's descendants,
// and the parent must be different from the child surface, otherwise the
// bad_parent protocol error is raised.
//
// This request modifies the behaviour of wl_surface.commit request on
// the sub-surface, see the documentation on wl_subsurface interface.
//
// surface : the surface to be turned into a sub-surface
// parent : the parent surface
func (i *WlSubcompositor) GetSubsurface(surface *WlSurface, parent *WlSurface) *WlSubsurface {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewWlSubsurface()
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(id)
	w.WriteObject(surface)
	w.WriteObject(parent)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// WlSubcompositorError :
type WlSubcompositorError uint32

const (
	// WlSubcompositorErrorBadSurface : the to-be sub-surface is invalid
	WlSubcompositorErrorBadSurface WlSubcompositorError = 0
	// WlSubcompositorErrorBadParent : the to-be sub-surface parent is invalid
	WlSubcompositorErrorBadParent WlSubcompositorError = 1
)

func (e WlSubcompositorError) Name() string {
	switch e {
	case WlSubcompositorErrorBadSurface:
		return "bad_surface"
	case WlSubcompositorErrorBadParent:
		return "bad_parent"
	default:
		return ""
	}
}
func (e WlSubcompositorError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlSubsurface : sub-surface interface to a wl_surface
//
// An additional interface to a wl_surface object, which has been
// made a sub-surface. A sub-surface has one parent surface. A
// sub-surface's size and position are not limited to that of the parent.
// Particularly, a sub-surface is not automatically clipped to its
// parent's area.
//
// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// and the parent surface is mapped. The order of which one happens
// first is irrelevant. A sub-surface is hidden if the parent becomes
// hidden, or if a NULL wl_buffer is applied. These rules apply
// recursively through the tree of surfaces.
//
// The behaviour of a wl_surface.commit request on a sub-surface
// depends on the sub-surface's mode. The possible modes are
// synchronized and desynchronized, see methods
// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// mode caches the wl_surface state to be applied when the parent's
// state gets applied, and desynchronized mode applies the pending
// wl_surface state directly. A sub-surface is initially in the
// synchronized mode.
//
// Sub-surfaces also have another kind of state, which is managed by
// wl_subsurface requests, as opposed to wl_surface requests. This
// state includes the sub-surface position relative to the parent
// surface (wl_subsurface.set_position), and the stacking order of
// the parent and its sub-surfaces (wl_subsurface.place_above and
// .place_below). This state is applied when the parent surface's
// wl_surface state is applied, regardless of the sub-surface's mode.
// As the exception, set_sync and set_desync are effective immediately.
//
// The main surface can be thought to be always in desynchronized mode,
// since it does not have a parent in the sub-surfaces sense.
//
// Even if a sub-surface is in desynchronized mode, it will behave as
// in synchronized mode, if its parent surface behaves as in
// synchronized mode. This rule is applied recursively throughout the
// tree of surfaces. This means, that one can set a sub-surface into
// synchronized mode, and then assume that all its child and grand-child
// sub-surfaces are synchronized, too, without explicitly setting them.
//
// Destroying a sub-surface takes effect immediately. If you need to
// synchronize the removal of a sub-surface to the parent surface update,
// unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
// and then destroy the sub-surface.
//
// If the parent wl_surface object is destroyed, the sub-surface is
// unmapped.
//
// A sub-surface never has the keyboard focus of any seat.
//
// The wl_surface.offset request is ignored: clients must use set_position
// instead to move the sub-surface.
type WlSubsurface struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlSubsurface : sub-surface interface to a wl_surface
//
// An additional interface to a wl_surface object, which has been
// made a sub-surface. A sub-surface has one parent surface. A
// sub-surface's size and position are not limited to that of the parent.
// Particularly, a sub-surface is not automatically clipped to its
// parent's area.
//
// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// and the parent surface is mapped. The order of which one happens
// first is irrelevant. A sub-surface is hidden if the parent becomes
// hidden, or if a NULL wl_buffer is applied. These rules apply
// recursively through the tree of surfaces.
//
// The behaviour of a wl_surface.commit request on a sub-surface
// depends on the sub-surface's mode. The possible modes are
// synchronized and desynchronized, see methods
// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// mode caches the wl_surface state to be applied when the parent's
// state gets applied, and desynchronized mode applies the pending
// wl_surface state directly. A sub-surface is initially in the
// synchronized mode.
//
// Sub-surfaces also have another kind of state, which is managed by
// wl_subsurface requests, as opposed to wl_surface requests. This
// state includes the sub-surface position relative to the parent
// surface (wl_subsurface.set_position), and the stacking order of
// the parent and its sub-surfaces (wl_subsurface.place_above and
// .place_below). This state is applied when the parent surface's
// wl_surface state is applied, regardless of the sub-surface's mode.
// As the exception, set_sync and set_desync are effective immediately.
//
// The main surface can be thought to be always in desynchronized mode,
// since it does not have a parent in the sub-surfaces sense.
//
// Even if a sub-surface is in desynchronized mode, it will behave as
// in synchronized mode, if its parent surface behaves as in
// synchronized mode. This rule is applied recursively throughout the
// tree of surfaces. This means, that one can set a sub-surface into
// synchronized mode, and then assume that all its child and grand-child
// sub-surfaces are synchronized, too, without explicitly setting them.
//
// Destroying a sub-surface takes effect immediately. If you need to
// synchronize the removal of a sub-surface to the parent surface update,
// unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
// and then destroy the sub-surface.
//
// If the parent wl_surface object is destroyed, the sub-surface is
// unmapped.
//
// A sub-surface never has the keyboard focus of any seat.
//
// The wl_surface.offset request is ignored: clients must use set_position
// instead to move the sub-surface.
func NewWlSubsurface() *WlSubsurface {
	return &WlSubsurface{}
}
func (i *WlSubsurface) Name() string {
	return "wl_subsurface"
}

// Destroy : remove sub-surface interface
//
// The sub-surface interface is removed from the wl_surface object
// that was turned into a sub-surface with a
// wl_subcompositor.get_subsurface request. The wl_surface's association
// to the parent is deleted. The wl_surface is unmapped immediately.
func (i *WlSubsurface) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetPosition : reposition the sub-surface
//
// This schedules a sub-surface position change.
// The sub-surface will be moved so that its origin (top left
// corner pixel) will be at the location x, y of the parent surface
// coordinate system. The coordinates are not restricted to the parent
// surface area. Negative values are allowed.
//
// The scheduled coordinates will take effect whenever the state of the
// parent surface is applied.
//
// If more than one set_position request is invoked by the client before
// the commit of the parent surface, the position of a new request always
// replaces the scheduled position from any previous request.
//
// The initial position is 0, 0.
//
// x : x coordinate in the parent surface
// y : y coordinate in the parent surface
func (i *WlSubsurface) SetPosition(x int32, y int32) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	w.WriteInt(x)
	w.WriteInt(y)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// PlaceAbove : restack the sub-surface
//
// This sub-surface is taken from the stack, and put back just
// above the reference surface, changing the z-order of the sub-surfaces.
// The reference surface must be one of the sibling surfaces, or the
// parent surface. Using any other surface, including this sub-surface,
// will cause a protocol error.
//
// The z-order is double-buffered. Requests are handled in order and
// applied immediately to a pending state. The final pending state is
// copied to the active state the next time the state of the parent
// surface is applied.
//
// A new sub-surface is initially added as the top-most in the stack
// of its siblings and parent.
//
// sibling : the reference surface
func (i *WlSubsurface) PlaceAbove(sibling *WlSurface) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 2)
	w.WriteObject(sibling)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// PlaceBelow : restack the sub-surface
//
// The sub-surface is placed just below the reference surface.
// See wl_subsurface.place_above.
//
// sibling : the reference surface
func (i *WlSubsurface) PlaceBelow(sibling *WlSurface) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 3)
	w.WriteObject(sibling)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetSync : set sub-surface to synchronized mode
//
// Change the commit behaviour of the sub-surface to synchronized
// mode, also described as the parent dependent mode.
//
// In synchronized mode, wl_surface.commit on a sub-surface will
// accumulate the committed state in a cache, but the state will
// not be applied and hence will not change the compositor output.
// The cached state is applied to the sub-surface immediately after
// the parent surface's state is applied. This ensures atomic
// updates of the parent and all its synchronized sub-surfaces.
// Applying the cached state will invalidate the cache, so further
// parent surface commits do not (re-)apply old state.
//
// See wl_subsurface for the recursive effect of this mode.
func (i *WlSubsurface) SetSync() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 4)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// SetDesync : set sub-surface to desynchronized mode
//
// Change the commit behaviour of the sub-surface to desynchronized
// mode, also described as independent or freely running mode.
//
// In desynchronized mode, wl_surface.commit on a sub-surface will
// apply the pending state directly, without caching, as happens
// normally with a wl_surface. Calling wl_surface.commit on the
// parent surface has no effect on the sub-surface's wl_surface
// state. This mode allows a sub-surface to be updated on its own.
//
// If cached state exists when wl_surface.commit is called in
// desynchronized mode, the pending state is added to the cached
// state, and applied as a whole. This invalidates the cache.
//
// Note: even if a sub-surface is set to desynchronized, a parent
// sub-surface may override it to behave as synchronized. For details,
// see wl_subsurface.
//
// If a surface's parent surface behaves as desynchronized, then
// the cached state is applied on set_desync.
func (i *WlSubsurface) SetDesync() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 5)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// WlSubsurfaceError :
type WlSubsurfaceError uint32

const (
	// WlSubsurfaceErrorBadSurface : wl_surface is not a sibling or the parent
	WlSubsurfaceErrorBadSurface WlSubsurfaceError = 0
)

func (e WlSubsurfaceError) Name() string {
	switch e {
	case WlSubsurfaceErrorBadSurface:
		return "bad_surface"
	default:
		return ""
	}
}
func (e WlSubsurfaceError) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// WlFixes : wayland protocol fixes
//
// This global fixes problems with other core-protocol interfaces that
// cannot be fixed in these interfaces themselves.
type WlFixes struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewWlFixes : wayland protocol fixes
//
// This global fixes problems with other core-protocol interfaces that
// cannot be fixed in these interfaces themselves.
func NewWlFixes() *WlFixes {
	return &WlFixes{}
}
func (i *WlFixes) Name() string {
	return "wl_fixes"
}

// Destroy : destroys this object
func (i *WlFixes) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// DestroyRegistry : destroy a wl_registry
//
// This request destroys a wl_registry object.
//
// The client should no longer use the wl_registry after making this
// request.
//
// The compositor will emit a wl_display.delete_id event with the object ID
// of the registry and will no longer emit any events on the registry. The
// client should re-use the object ID once it receives the
// wl_display.delete_id event.
//
// registry : the registry to destroy
func (i *WlFixes) DestroyRegistry(registry *WlRegistry) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	w.WriteObject(registry)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}
func GetWaylandInterface(name string, handler wayland.EventHandler) wayland.Proxy {
	switch name {
	case "wl_display":
		return NewWlDisplay(handler)
	case "wl_registry":
		return NewWlRegistry(handler)
	case "wl_callback":
		return NewWlCallback(handler)
	case "wl_compositor":
		return NewWlCompositor()
	case "wl_shm_pool":
		return NewWlShmPool()
	case "wl_shm":
		return NewWlShm(handler)
	case "wl_buffer":
		return NewWlBuffer(handler)
	case "wl_data_offer":
		return NewWlDataOffer(handler)
	case "wl_data_source":
		return NewWlDataSource(handler)
	case "wl_data_device":
		return NewWlDataDevice(handler)
	case "wl_data_device_manager":
		return NewWlDataDeviceManager()
	case "wl_shell":
		return NewWlShell()
	case "wl_shell_surface":
		return NewWlShellSurface(handler)
	case "wl_surface":
		return NewWlSurface(handler)
	case "wl_seat":
		return NewWlSeat(handler)
	case "wl_pointer":
		return NewWlPointer(handler)
	case "wl_keyboard":
		return NewWlKeyboard(handler)
	case "wl_touch":
		return NewWlTouch(handler)
	case "wl_output":
		return NewWlOutput(handler)
	case "wl_region":
		return NewWlRegion()
	case "wl_subcompositor":
		return NewWlSubcompositor()
	case "wl_subsurface":
		return NewWlSubsurface()
	case "wl_fixes":
		return NewWlFixes()
	default:
		return nil
	}
}
