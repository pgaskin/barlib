// Generated by gowls using arguments "--package wlproto --output wlr-gamma-control-unstable-v1.go wlr-gamma-control-unstable-v1.xml". DO NOT EDIT.
// https://github.com/friedelschoen/wayland/cmd/gowls
//
// XML file : wlr-gamma-control-unstable-v1.xml
//
// wlr_gamma_control_unstable_v1 Protocol Copyright:
//
// Copyright © 2015 Giulio camuffo
// Copyright © 2018 Simon Ser
//
// Permission to use, copy, modify, distribute, and sell this
// software and its documentation for any purpose is hereby granted
// without fee, provided that the above copyright notice appear in
// all copies and that both that copyright notice and this permission
// notice appear in supporting documentation, and that the name of
// the copyright holders not be used in advertising or publicity
// pertaining to distribution of the software without specific,
// written prior permission.  The copyright holders make no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied
// warranty.
//
// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.
//

// Package wlproto contains wayland-protocol wlr_gamma_control_unstable_v1
package wlproto

import wayland "github.com/friedelschoen/wayland"
import "fmt"

// ZwlrGammaControlManagerV1 : manager to create per-output gamma controls
//
// This interface is a manager that allows creating per-output gamma
// controls.
type ZwlrGammaControlManagerV1 struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
}

// NewZwlrGammaControlManagerV1 : manager to create per-output gamma controls
//
// This interface is a manager that allows creating per-output gamma
// controls.
func NewZwlrGammaControlManagerV1() *ZwlrGammaControlManagerV1 {
	return &ZwlrGammaControlManagerV1{}
}
func (i *ZwlrGammaControlManagerV1) Name() string {
	return "zwlr_gamma_control_manager_v1"
}

// GetGammaControl : get a gamma control for an output
//
// Create a gamma control that can be used to adjust gamma tables for the
// provided output.
//
// idHandlers : handler for ZwlrGammaControlV1, possible events are ZwlrGammaControlV1GammaSize, ZwlrGammaControlV1Failed
func (i *ZwlrGammaControlManagerV1) GetGammaControl(output *WlOutput, idHandlers wayland.EventHandler) *ZwlrGammaControlV1 {
	if i == nil || !i.Valid() {
		return nil
	}
	id := NewZwlrGammaControlV1(idHandlers)
	i.Conn().Register(id)
	i.adjacent = append(i.adjacent, id)
	w := wayland.NewMessageWriter(i, 0)
	w.WriteObject(id)
	w.WriteObject(output)
	if err := w.Finish(); err != nil {
		panic(err)
	}
	return id
}

// Destroy : destroy the manager
//
// All objects created by the manager will still remain valid, until their
// appropriate destroy request has been called.
func (i *ZwlrGammaControlManagerV1) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// ZwlrGammaControlV1 : adjust gamma tables for an output
//
// This interface allows a client to adjust gamma tables for a particular
// output.
//
// The client will receive the gamma size, and will then be able to set gamma
// tables. At any time the compositor can send a failed event indicating that
// this object is no longer valid.
//
// There can only be at most one gamma control object per output, which
// has exclusive access to this particular output. When the gamma control
// object is destroyed, the gamma table is restored to its original value.
type ZwlrGammaControlV1 struct {
	wayland.BaseProxy
	adjacent []wayland.Proxy
	Handler  wayland.EventHandler
}
type ZwlrGammaControlV1Handlers struct {
	OnGammaSize wayland.EventHandler
	OnFailed    wayland.EventHandler
	Unhandled   wayland.EventHandler
}

func (h ZwlrGammaControlV1Handlers) Handle(e wayland.Event) bool {
	switch e := e.(type) {
	case *ZwlrGammaControlV1GammaSizeEvent:
		if h.OnGammaSize != nil && h.OnGammaSize.Handle(e) {
			return true
		}
	case *ZwlrGammaControlV1FailedEvent:
		if h.OnFailed != nil && h.OnFailed.Handle(e) {
			return true
		}
	}
	if h.Unhandled != nil {
		return h.Unhandled.Handle(e)
	}
	return false
}

// NewZwlrGammaControlV1 : adjust gamma tables for an output
//
// This interface allows a client to adjust gamma tables for a particular
// output.
//
// The client will receive the gamma size, and will then be able to set gamma
// tables. At any time the compositor can send a failed event indicating that
// this object is no longer valid.
//
// There can only be at most one gamma control object per output, which
// has exclusive access to this particular output. When the gamma control
// object is destroyed, the gamma table is restored to its original value.
func NewZwlrGammaControlV1(handler wayland.EventHandler) *ZwlrGammaControlV1 {
	return &ZwlrGammaControlV1{Handler: handler}
}
func (i *ZwlrGammaControlV1) Name() string {
	return "zwlr_gamma_control_v1"
}

// SetGamma : set the gamma table
//
// Set the gamma table. The file descriptor can be memory-mapped to provide
// the raw gamma table, which contains successive gamma ramps for the red,
// green and blue channels. Each gamma ramp is an array of 16-byte unsigned
// integers which has the same length as the gamma size.
//
// The file descriptor data must have the same length as three times the
// gamma size.
//
// fd : gamma table file descriptor
func (i *ZwlrGammaControlV1) SetGamma(fd int) {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 0)
	w.WriteFd(fd)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// Destroy : destroy this control
//
// Destroys the gamma control object. If the object is still valid, this
// restores the original gamma tables.
func (i *ZwlrGammaControlV1) Destroy() {
	if i == nil || !i.Valid() {
		return
	}
	w := wayland.NewMessageWriter(i, 1)
	if err := w.Finish(); err != nil {
		panic(err)
	}
}

// ZwlrGammaControlV1Error :
type ZwlrGammaControlV1Error uint32

const (
	// ZwlrGammaControlV1ErrorInvalidGamma : invalid gamma tables
	ZwlrGammaControlV1ErrorInvalidGamma ZwlrGammaControlV1Error = 1
)

func (e ZwlrGammaControlV1Error) Name() string {
	switch e {
	case ZwlrGammaControlV1ErrorInvalidGamma:
		return "invalid_gamma"
	default:
		return ""
	}
}
func (e ZwlrGammaControlV1Error) String() string {
	name := e.Name()
	if name == "" {
		return fmt.Sprintf("error(%d)", e)
	}
	return fmt.Sprintf("error(%s)", name)
}

// ZwlrGammaControlV1GammaSizeEvent : size of gamma ramps
//
// Advertise the size of each gamma ramp.
//
// This event is sent immediately when the gamma control object is created.
type ZwlrGammaControlV1GammaSizeEvent struct {
	size  uint32
	proxy wayland.Proxy
}

// Size number of elements in a ramp
func (e *ZwlrGammaControlV1GammaSizeEvent) Size() uint32 {
	return e.size
}

func (e *ZwlrGammaControlV1GammaSizeEvent) Proxy() wayland.Proxy {
	return e.proxy
}

// ZwlrGammaControlV1FailedEvent : object no longer valid
//
// This event indicates that the gamma control is no longer valid. This
// can happen for a number of reasons, including:
// - The output doesn't support gamma tables
// - Setting the gamma tables failed
// - Another client already has exclusive gamma control for this output
// - The compositor has transferred gamma control to another client
//
// Upon receiving this event, the client should destroy this object.
type ZwlrGammaControlV1FailedEvent struct {
	proxy wayland.Proxy
}

func (e *ZwlrGammaControlV1FailedEvent) Proxy() wayland.Proxy {
	return e.proxy
}
func (i *ZwlrGammaControlV1) Dispatch(msg *wayland.Message) {
	switch msg.Opcode {
	case 0:
		if i.Handler == nil {
			return
		}
		e := &ZwlrGammaControlV1GammaSizeEvent{proxy: i}
		r := wayland.NewMessageReader(i.Conn(), msg)
		e.size = r.ReadUint()
		if i.Handler.Handle(e) {
			return
		}
	case 1:
		if i.Handler == nil {
			return
		}
		e := &ZwlrGammaControlV1FailedEvent{proxy: i}
		if i.Handler.Handle(e) {
			return
		}
	}
}
func GetWlrGammaControlUnstableV1Interface(name string, handler wayland.EventHandler) wayland.Proxy {
	switch name {
	case "zwlr_gamma_control_manager_v1":
		return NewZwlrGammaControlManagerV1()
	case "zwlr_gamma_control_v1":
		return NewZwlrGammaControlV1(handler)
	default:
		return nil
	}
}
